; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_bmp085.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_bmp085.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_bmp085.crf ..\..\User\bsp_stm32f4xx\src\bsp_bmp085.c]
                          THUMB

                          AREA ||i.BMP085_Read2Bytes||, CODE, READONLY, ALIGN=1

                  BMP085_Read2Bytes PROC
;;;172    */
;;;173    static uint16_t BMP085_Read2Bytes(uint8_t _ucRegAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;174    {
000004  4604              MOV      r4,r0
;;;175    	uint8_t ucData1;
;;;176    	uint8_t ucData2;
;;;177    	uint16_t usRegValue;
;;;178    
;;;179    	i2c_Start();                  			/* 总线开始信号 */
000006  f7fffffe          BL       i2c_Start
;;;180    	i2c_SendByte(BMP085_SLAVE_ADDRESS);		/* 发送设备地址+写信号 */
00000a  20ee              MOVS     r0,#0xee
00000c  f7fffffe          BL       i2c_SendByte
;;;181    	i2c_WaitAck();
000010  f7fffffe          BL       i2c_WaitAck
;;;182    	i2c_SendByte(_ucRegAddr);				/* 发送地址 */
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       i2c_SendByte
;;;183    	i2c_WaitAck();
00001a  f7fffffe          BL       i2c_WaitAck
;;;184    
;;;185    	i2c_Start();                  			/* 总线开始信号 */
00001e  f7fffffe          BL       i2c_Start
;;;186    	i2c_SendByte(BMP085_SLAVE_ADDRESS + 1);/* 发送设备地址+读信号 */
000022  20ef              MOVS     r0,#0xef
000024  f7fffffe          BL       i2c_SendByte
;;;187    	i2c_WaitAck();
000028  f7fffffe          BL       i2c_WaitAck
;;;188    
;;;189    	ucData1 = i2c_ReadByte();       		/* 读出高字节数据 */
00002c  f7fffffe          BL       i2c_ReadByte
000030  4605              MOV      r5,r0
;;;190    	i2c_Ack();
000032  f7fffffe          BL       i2c_Ack
;;;191    
;;;192    	ucData2 = i2c_ReadByte();       		/* 读出低字节数据 */
000036  f7fffffe          BL       i2c_ReadByte
00003a  4606              MOV      r6,r0
;;;193    	i2c_NAck();
00003c  f7fffffe          BL       i2c_NAck
;;;194    	i2c_Stop();                  			/* 总线停止信号 */
000040  f7fffffe          BL       i2c_Stop
;;;195    
;;;196    	usRegValue = (ucData1 << 8) + ucData2;
000044  eb062005          ADD      r0,r6,r5,LSL #8
000048  b287              UXTH     r7,r0
;;;197    
;;;198    	return usRegValue;
00004a  4638              MOV      r0,r7
;;;199    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;200    
                          ENDP


                          AREA ||i.BMP085_Read3Bytes||, CODE, READONLY, ALIGN=1

                  BMP085_Read3Bytes PROC
;;;208    */
;;;209    static uint32_t BMP085_Read3Bytes(uint8_t _ucRegAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;210    {
000004  4604              MOV      r4,r0
;;;211    	uint8_t ucData1;
;;;212    	uint8_t ucData2;
;;;213    	uint8_t ucData3;
;;;214    	uint32_t uiRegValue;
;;;215    
;;;216    	i2c_Start();                  			/* 总线开始信号 */
000006  f7fffffe          BL       i2c_Start
;;;217    	i2c_SendByte(BMP085_SLAVE_ADDRESS);		/* 发送设备地址+写信号 */
00000a  20ee              MOVS     r0,#0xee
00000c  f7fffffe          BL       i2c_SendByte
;;;218    	i2c_WaitAck();
000010  f7fffffe          BL       i2c_WaitAck
;;;219    	i2c_SendByte(_ucRegAddr);				/* 发送地址 */
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       i2c_SendByte
;;;220    	i2c_WaitAck();
00001a  f7fffffe          BL       i2c_WaitAck
;;;221    
;;;222    	i2c_Start();                  			/* 总线开始信号 */
00001e  f7fffffe          BL       i2c_Start
;;;223    	i2c_SendByte(BMP085_SLAVE_ADDRESS + 1);/* 发送设备地址+读信号 */
000022  20ef              MOVS     r0,#0xef
000024  f7fffffe          BL       i2c_SendByte
;;;224    	i2c_WaitAck();
000028  f7fffffe          BL       i2c_WaitAck
;;;225    
;;;226    	ucData1 = i2c_ReadByte();       		/* 读出高字节数据 */
00002c  f7fffffe          BL       i2c_ReadByte
000030  4605              MOV      r5,r0
;;;227    	i2c_Ack();
000032  f7fffffe          BL       i2c_Ack
;;;228    
;;;229    	ucData2 = i2c_ReadByte();       		/* 读出中间字节数据 */
000036  f7fffffe          BL       i2c_ReadByte
00003a  4606              MOV      r6,r0
;;;230    	i2c_Ack();
00003c  f7fffffe          BL       i2c_Ack
;;;231    
;;;232    	ucData3 = i2c_ReadByte();       		/* 读出最低节数据 */
000040  f7fffffe          BL       i2c_ReadByte
000044  4607              MOV      r7,r0
;;;233    	i2c_NAck();
000046  f7fffffe          BL       i2c_NAck
;;;234    	i2c_Stop();                  			/* 总线停止信号 */
00004a  f7fffffe          BL       i2c_Stop
;;;235    
;;;236    	uiRegValue = (ucData1 << 16) + (ucData2 << 8) + ucData3;
00004e  0428              LSLS     r0,r5,#16
000050  eb002006          ADD      r0,r0,r6,LSL #8
000054  eb000807          ADD      r8,r0,r7
;;;237    
;;;238    	return uiRegValue;
000058  4640              MOV      r0,r8
;;;239    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;240    
                          ENDP


                          AREA ||i.BMP085_ReadTempPress||, CODE, READONLY, ALIGN=2

                  BMP085_ReadTempPress PROC
;;;276    */
;;;277    void BMP085_ReadTempPress(void)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;278    {
;;;279    	long UT, X1, X2, B5, T;
;;;280    	long UP, X3, B3, B6, B7, p;
;;;281    	unsigned long B4;
;;;282    
;;;283    	/* 流程见 pdf page 12 */
;;;284    
;;;285    	/* 读温度原始值 */
;;;286    	BMP085_WriteReg(0xF4, 0x2E);
000004  212e              MOVS     r1,#0x2e
000006  20f4              MOVS     r0,#0xf4
000008  f7fffffe          BL       BMP085_WriteReg
;;;287    	BMP085_WaitConvert();	/* 等待转换结束 */
00000c  f7fffffe          BL       BMP085_WaitConvert
;;;288    	UT = BMP085_Read2Bytes(0xF6);
000010  20f6              MOVS     r0,#0xf6
000012  f7fffffe          BL       BMP085_Read2Bytes
000016  9003              STR      r0,[sp,#0xc]
;;;289    
;;;290    	/* 读压力原始值 */
;;;291    	BMP085_WriteReg(0xF4, 0x34 + (g_tBMP085.OSS << 6));
000018  4844              LDR      r0,|L3.300|
00001a  7d80              LDRB     r0,[r0,#0x16]  ; g_tBMP085
00001c  2234              MOVS     r2,#0x34
00001e  eb021080          ADD      r0,r2,r0,LSL #6
000022  b2c1              UXTB     r1,r0
000024  20f4              MOVS     r0,#0xf4
000026  f7fffffe          BL       BMP085_WriteReg
;;;292    	BMP085_WaitConvert();	/* 等待转换结束 */
00002a  f7fffffe          BL       BMP085_WaitConvert
;;;293    	UP = BMP085_Read3Bytes(0xF6) >> (8 - g_tBMP085.OSS);
00002e  20f6              MOVS     r0,#0xf6
000030  f7fffffe          BL       BMP085_Read3Bytes
000034  493d              LDR      r1,|L3.300|
000036  7d89              LDRB     r1,[r1,#0x16]  ; g_tBMP085
000038  f1c10108          RSB      r1,r1,#8
00003c  40c8              LSRS     r0,r0,r1
00003e  9001              STR      r0,[sp,#4]
;;;294    
;;;295    	/* 计算真实温度（单位 0.1摄氏度） */
;;;296    	X1 = ((long)(UT - g_tBMP085.AC6) * g_tBMP085.AC5) >> 15;
000040  483a              LDR      r0,|L3.300|
000042  8941              LDRH     r1,[r0,#0xa]  ; g_tBMP085
000044  9803              LDR      r0,[sp,#0xc]
000046  1a40              SUBS     r0,r0,r1
000048  4938              LDR      r1,|L3.300|
00004a  8909              LDRH     r1,[r1,#8]  ; g_tBMP085
00004c  4348              MULS     r0,r1,r0
00004e  13c4              ASRS     r4,r0,#15
;;;297    	X2 = ((long)g_tBMP085.MC << 11) / (X1 + g_tBMP085.MD);
000050  4836              LDR      r0,|L3.300|
000052  f9b00012          LDRSH    r0,[r0,#0x12]  ; g_tBMP085
000056  02c0              LSLS     r0,r0,#11
000058  4934              LDR      r1,|L3.300|
00005a  f9b11014          LDRSH    r1,[r1,#0x14]  ; g_tBMP085
00005e  4421              ADD      r1,r1,r4
000060  fb90f6f1          SDIV     r6,r0,r1
;;;298    	B5 = X1 + X2;	/* 该系数将用于压力的温度补偿计算 */
000064  eb040906          ADD      r9,r4,r6
;;;299    	T = (B5 + 8) >> 4;
000068  f1090008          ADD      r0,r9,#8
00006c  1100              ASRS     r0,r0,#4
00006e  9002              STR      r0,[sp,#8]
;;;300    	g_tBMP085.Temp = T;		/* 将计算结果保存在全局变量 */
000070  492e              LDR      r1,|L3.300|
000072  9802              LDR      r0,[sp,#8]
000074  6188              STR      r0,[r1,#0x18]  ; g_tBMP085
;;;301    
;;;302    	/* 计算真实压力值（单位 Pa） */
;;;303    	B6 = B5 - 4000;
000076  f5a9677a          SUB      r7,r9,#0xfa0
;;;304    	X1 = (g_tBMP085.B2 * (B6 * B6) >> 12) >> 11;
00007a  4608              MOV      r0,r1
00007c  f9b0000e          LDRSH    r0,[r0,#0xe]  ; g_tBMP085
000080  fb07f107          MUL      r1,r7,r7
000084  4348              MULS     r0,r1,r0
000086  15c4              ASRS     r4,r0,#23
;;;305    	X2 = (g_tBMP085.AC2 * B6) >> 11;
000088  4828              LDR      r0,|L3.300|
00008a  f9b00002          LDRSH    r0,[r0,#2]  ; g_tBMP085
00008e  4378              MULS     r0,r7,r0
000090  12c6              ASRS     r6,r0,#11
;;;306    	X3 = X1 + X2;
000092  eb040a06          ADD      r10,r4,r6
;;;307    	B3 = (((((long)g_tBMP085.AC1) * 4 + X3) << g_tBMP085.OSS) + 2) >> 2;
000096  4825              LDR      r0,|L3.300|
000098  f9b00000          LDRSH    r0,[r0,#0]  ; g_tBMP085
00009c  eb0a0080          ADD      r0,r10,r0,LSL #2
0000a0  4922              LDR      r1,|L3.300|
0000a2  7d89              LDRB     r1,[r1,#0x16]  ; g_tBMP085
0000a4  4088              LSLS     r0,r0,r1
0000a6  1c80              ADDS     r0,r0,#2
0000a8  1080              ASRS     r0,r0,#2
0000aa  9000              STR      r0,[sp,#0]
;;;308    
;;;309    	X1 = (g_tBMP085.AC3 * B6) >> 13;
0000ac  481f              LDR      r0,|L3.300|
0000ae  f9b00004          LDRSH    r0,[r0,#4]  ; g_tBMP085
0000b2  4378              MULS     r0,r7,r0
0000b4  1344              ASRS     r4,r0,#13
;;;310    	X2 = (g_tBMP085.B1 * ((B6 * B6) >> 12)) >> 16;
0000b6  481d              LDR      r0,|L3.300|
0000b8  f9b0000c          LDRSH    r0,[r0,#0xc]  ; g_tBMP085
0000bc  fb07f107          MUL      r1,r7,r7
0000c0  1309              ASRS     r1,r1,#12
0000c2  4348              MULS     r0,r1,r0
0000c4  1406              ASRS     r6,r0,#16
;;;311    	X3 = ((X1 + X2) + 2) >> 2;
0000c6  19a0              ADDS     r0,r4,r6
0000c8  1c80              ADDS     r0,r0,#2
0000ca  ea4f0aa0          ASR      r10,r0,#2
;;;312    	B4 = (g_tBMP085.AC4 * (unsigned long)(X3 + 32768)) >> 15;
0000ce  4817              LDR      r0,|L3.300|
0000d0  88c0              LDRH     r0,[r0,#6]  ; g_tBMP085
0000d2  f50a4100          ADD      r1,r10,#0x8000
0000d6  4348              MULS     r0,r1,r0
0000d8  ea4f3bd0          LSR      r11,r0,#15
;;;313    
;;;314    	B7 = ((unsigned long)(UP - B3) * (50000 >> g_tBMP085.OSS));
0000dc  e9dd1000          LDRD     r1,r0,[sp,#0]
0000e0  1a40              SUBS     r0,r0,r1
0000e2  4912              LDR      r1,|L3.300|
0000e4  7d8a              LDRB     r2,[r1,#0x16]  ; g_tBMP085
0000e6  f24c3150          MOV      r1,#0xc350
0000ea  4111              ASRS     r1,r1,r2
0000ec  fb00f801          MUL      r8,r0,r1
;;;315    	if (B7 < 0x80000000)
0000f0  f1b84f00          CMP      r8,#0x80000000
0000f4  d204              BCS      |L3.256|
;;;316    	{
;;;317    		p = (B7 << 1) / B4;
0000f6  ea4f0048          LSL      r0,r8,#1
0000fa  fbb0f5fb          UDIV     r5,r0,r11
0000fe  e002              B        |L3.262|
                  |L3.256|
;;;318    	}
;;;319    	else
;;;320    	{
;;;321    		p = (B7 / B4) << 1;
000100  fbb8f0fb          UDIV     r0,r8,r11
000104  0045              LSLS     r5,r0,#1
                  |L3.262|
;;;322    	}
;;;323    
;;;324    	X1 = (p >> 8) * (p >> 8);
000106  1228              ASRS     r0,r5,#8
000108  fb00f400          MUL      r4,r0,r0
;;;325    	X1 = (X1 * 3038) >> 16;
00010c  f64030de          MOV      r0,#0xbde
000110  4360              MULS     r0,r4,r0
000112  1404              ASRS     r4,r0,#16
;;;326    	X2 = (-7357 * p) >> 16;
000114  4806              LDR      r0,|L3.304|
000116  4368              MULS     r0,r5,r0
000118  1406              ASRS     r6,r0,#16
;;;327     	p =  p + ((X1 + X2 + 3791) >> 4);
00011a  19a0              ADDS     r0,r4,r6
00011c  f60060cf          ADD      r0,r0,#0xecf
000120  eb051520          ADD      r5,r5,r0,ASR #4
;;;328    
;;;329    	g_tBMP085.Press = p;		/* 将计算结果保存在全局变量 */
000124  4801              LDR      r0,|L3.300|
000126  61c5              STR      r5,[r0,#0x1c]  ; g_tBMP085
;;;330    }
000128  e8bd9fff          POP      {r0-r12,pc}
;;;331    
                          ENDP

                  |L3.300|
                          DCD      g_tBMP085
                  |L3.304|
                          DCD      0xffffe343

                          AREA ||i.BMP085_WaitConvert||, CODE, READONLY, ALIGN=2

                  BMP085_WaitConvert PROC
;;;248    */
;;;249    static void BMP085_WaitConvert(void)
000000  b510              PUSH     {r4,lr}
;;;250    {
;;;251    	if (g_tBMP085.OSS == 0)
000002  480f              LDR      r0,|L4.64|
000004  7d80              LDRB     r0,[r0,#0x16]  ; g_tBMP085
000006  b918              CBNZ     r0,|L4.16|
;;;252    	{
;;;253    		bsp_DelayMS(6);		/* 4.5ms  7.5ms  13.5ms   25.5ms */
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       bsp_DelayMS
00000e  e016              B        |L4.62|
                  |L4.16|
;;;254    	}
;;;255    	else if (g_tBMP085.OSS == 1)
000010  480b              LDR      r0,|L4.64|
000012  7d80              LDRB     r0,[r0,#0x16]  ; g_tBMP085
000014  2801              CMP      r0,#1
000016  d103              BNE      |L4.32|
;;;256    	{
;;;257    		bsp_DelayMS(9);		/* 4.5ms  7.5ms  13.5ms   25.5ms */
000018  2009              MOVS     r0,#9
00001a  f7fffffe          BL       bsp_DelayMS
00001e  e00e              B        |L4.62|
                  |L4.32|
;;;258    	}
;;;259    	else if (g_tBMP085.OSS == 2)
000020  4807              LDR      r0,|L4.64|
000022  7d80              LDRB     r0,[r0,#0x16]  ; g_tBMP085
000024  2802              CMP      r0,#2
000026  d103              BNE      |L4.48|
;;;260    	{
;;;261    		bsp_DelayMS(15);	/* 4.5ms  7.5ms  13.5ms   25.5ms */
000028  200f              MOVS     r0,#0xf
00002a  f7fffffe          BL       bsp_DelayMS
00002e  e006              B        |L4.62|
                  |L4.48|
;;;262    	}
;;;263    	else if (g_tBMP085.OSS == 3)
000030  4803              LDR      r0,|L4.64|
000032  7d80              LDRB     r0,[r0,#0x16]  ; g_tBMP085
000034  2803              CMP      r0,#3
000036  d102              BNE      |L4.62|
;;;264    	{
;;;265    		bsp_DelayMS(27);	/* 4.5ms  7.5ms  13.5ms   25.5ms */
000038  201b              MOVS     r0,#0x1b
00003a  f7fffffe          BL       bsp_DelayMS
                  |L4.62|
;;;266    	}
;;;267    }
00003e  bd10              POP      {r4,pc}
;;;268    
                          ENDP

                  |L4.64|
                          DCD      g_tBMP085

                          AREA ||i.BMP085_WriteReg||, CODE, READONLY, ALIGN=1

                  BMP085_WriteReg PROC
;;;148    */
;;;149    static void BMP085_WriteReg(uint8_t _ucRegAddr, uint8_t _ucRegValue)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;151        i2c_Start();							/* 总线开始信号 */
000006  f7fffffe          BL       i2c_Start
;;;152    
;;;153        i2c_SendByte(BMP085_SLAVE_ADDRESS);		/* 发送设备地址+写信号 */
00000a  20ee              MOVS     r0,#0xee
00000c  f7fffffe          BL       i2c_SendByte
;;;154    	i2c_WaitAck();
000010  f7fffffe          BL       i2c_WaitAck
;;;155    
;;;156        i2c_SendByte(_ucRegAddr);				/* 发送寄存器地址 */
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       i2c_SendByte
;;;157    	i2c_WaitAck();
00001a  f7fffffe          BL       i2c_WaitAck
;;;158    
;;;159        i2c_SendByte(_ucRegValue);				/* 发送寄存器数值 */
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       i2c_SendByte
;;;160    	i2c_WaitAck();
000024  f7fffffe          BL       i2c_WaitAck
;;;161    
;;;162        i2c_Stop();                   			/* 总线停止信号 */
000028  f7fffffe          BL       i2c_Stop
;;;163    }
00002c  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.bsp_InitBMP085||, CODE, READONLY, ALIGN=2

                  bsp_InitBMP085 PROC
;;;121    */
;;;122    void bsp_InitBMP085(void)
000000  b510              PUSH     {r4,lr}
;;;123    {
;;;124    	/* 读出芯片内部的校准参数（每个芯片不同，这是BOSCH出厂前校准好的数据） */
;;;125    	g_tBMP085.AC1 = (int16_t)BMP085_Read2Bytes(0xAA);
000002  20aa              MOVS     r0,#0xaa
000004  f7fffffe          BL       BMP085_Read2Bytes
000008  b200              SXTH     r0,r0
00000a  491f              LDR      r1,|L6.136|
00000c  8008              STRH     r0,[r1,#0]
;;;126    	g_tBMP085.AC2 = (int16_t)BMP085_Read2Bytes(0xAC);
00000e  20ac              MOVS     r0,#0xac
000010  f7fffffe          BL       BMP085_Read2Bytes
000014  b200              SXTH     r0,r0
000016  491c              LDR      r1,|L6.136|
000018  8048              STRH     r0,[r1,#2]
;;;127    	g_tBMP085.AC3 = (int16_t)BMP085_Read2Bytes(0xAE);
00001a  20ae              MOVS     r0,#0xae
00001c  f7fffffe          BL       BMP085_Read2Bytes
000020  b200              SXTH     r0,r0
000022  4919              LDR      r1,|L6.136|
000024  8088              STRH     r0,[r1,#4]
;;;128    	g_tBMP085.AC4 = (uint16_t)BMP085_Read2Bytes(0xB0);
000026  20b0              MOVS     r0,#0xb0
000028  f7fffffe          BL       BMP085_Read2Bytes
00002c  4916              LDR      r1,|L6.136|
00002e  80c8              STRH     r0,[r1,#6]
;;;129    	g_tBMP085.AC5 = (uint16_t)BMP085_Read2Bytes(0xB2);
000030  20b2              MOVS     r0,#0xb2
000032  f7fffffe          BL       BMP085_Read2Bytes
000036  4914              LDR      r1,|L6.136|
000038  8108              STRH     r0,[r1,#8]
;;;130    	g_tBMP085.AC6 = (uint16_t)BMP085_Read2Bytes(0xB4);
00003a  20b4              MOVS     r0,#0xb4
00003c  f7fffffe          BL       BMP085_Read2Bytes
000040  4911              LDR      r1,|L6.136|
000042  8148              STRH     r0,[r1,#0xa]
;;;131    	g_tBMP085.B1 =  (int16_t)BMP085_Read2Bytes(0xB6);
000044  20b6              MOVS     r0,#0xb6
000046  f7fffffe          BL       BMP085_Read2Bytes
00004a  b200              SXTH     r0,r0
00004c  490e              LDR      r1,|L6.136|
00004e  8188              STRH     r0,[r1,#0xc]
;;;132    	g_tBMP085.B2 =  (int16_t)BMP085_Read2Bytes(0xB8);
000050  20b8              MOVS     r0,#0xb8
000052  f7fffffe          BL       BMP085_Read2Bytes
000056  b200              SXTH     r0,r0
000058  490b              LDR      r1,|L6.136|
00005a  81c8              STRH     r0,[r1,#0xe]
;;;133    	g_tBMP085.MB =  (int16_t)BMP085_Read2Bytes(0xBA);
00005c  20ba              MOVS     r0,#0xba
00005e  f7fffffe          BL       BMP085_Read2Bytes
000062  b200              SXTH     r0,r0
000064  4908              LDR      r1,|L6.136|
000066  8208              STRH     r0,[r1,#0x10]
;;;134    	g_tBMP085.MC =  (int16_t)BMP085_Read2Bytes(0xBC);
000068  20bc              MOVS     r0,#0xbc
00006a  f7fffffe          BL       BMP085_Read2Bytes
00006e  b200              SXTH     r0,r0
000070  4905              LDR      r1,|L6.136|
000072  8248              STRH     r0,[r1,#0x12]
;;;135    	g_tBMP085.MD =  (int16_t)BMP085_Read2Bytes(0xBE);
000074  20be              MOVS     r0,#0xbe
000076  f7fffffe          BL       BMP085_Read2Bytes
00007a  b200              SXTH     r0,r0
00007c  4902              LDR      r1,|L6.136|
00007e  8288              STRH     r0,[r1,#0x14]
;;;136    
;;;137    	g_tBMP085.OSS = 0;	/* 过采样参数，0-3 */
000080  2000              MOVS     r0,#0
000082  7588              STRB     r0,[r1,#0x16]
;;;138    }
000084  bd10              POP      {r4,pc}
;;;139    
                          ENDP

000086  0000              DCW      0x0000
                  |L6.136|
                          DCD      g_tBMP085

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tBMP085
                          %        32

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_bmp085.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_bmp085_c_190e169e____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_bmp085_c_190e169e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_bmp085_c_190e169e____REVSH|
#line 144
|__asm___12_bsp_bmp085_c_190e169e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
