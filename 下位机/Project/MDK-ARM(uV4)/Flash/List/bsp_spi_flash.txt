; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_flash.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_spi_flash.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_flash.c]
                          THUMB

                          AREA ||i.bsp_CfgSPIForSFlash||, CODE, READONLY, ALIGN=2

                  bsp_CfgSPIForSFlash PROC
;;;235    */
;;;236    static void bsp_CfgSPIForSFlash(void)
000000  b500              PUSH     {lr}
;;;237    {
000002  b085              SUB      sp,sp,#0x14
;;;238    	SPI_InitTypeDef  SPI_InitStructure;
;;;239    
;;;240    	/* 打开SPI时钟 */
;;;241    	ENABLE_SPI_RCC();
000004  2101              MOVS     r1,#1
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;242    
;;;243    	/* 配置SPI硬件参数 */
;;;244    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
00000c  2000              MOVS     r0,#0
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;245    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
000012  f44f7082          MOV      r0,#0x104
000016  f8ad0002          STRH     r0,[sp,#2]
;;;246    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
00001a  2000              MOVS     r0,#0
00001c  f8ad0004          STRH     r0,[sp,#4]
;;;247    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;248    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;249    	*/
;;;250    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000020  2002              MOVS     r0,#2
000022  f8ad0006          STRH     r0,[sp,#6]
;;;251    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
000026  2001              MOVS     r0,#1
000028  f8ad0008          STRH     r0,[sp,#8]
;;;252    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
00002c  0240              LSLS     r0,r0,#9
00002e  f8ad000a          STRH     r0,[sp,#0xa]
;;;253    
;;;254    	/* 设置波特率预分频系数 */
;;;255    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BAUD;
000032  2008              MOVS     r0,#8
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;256    
;;;257    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000038  2000              MOVS     r0,#0
00003a  f8ad000e          STRH     r0,[sp,#0xe]
;;;258    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
00003e  2007              MOVS     r0,#7
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;259    	SPI_Init(SPI_FLASH, &SPI_InitStructure);
000044  4669              MOV      r1,sp
000046  4806              LDR      r0,|L1.96|
000048  f7fffffe          BL       SPI_Init
;;;260    
;;;261    	SPI_Cmd(SPI_FLASH, DISABLE);			/* 先禁止SPI  */
00004c  2100              MOVS     r1,#0
00004e  4804              LDR      r0,|L1.96|
000050  f7fffffe          BL       SPI_Cmd
;;;262    
;;;263    	SPI_Cmd(SPI_FLASH, ENABLE);				/* 使能SPI  */
000054  2101              MOVS     r1,#1
000056  4802              LDR      r0,|L1.96|
000058  f7fffffe          BL       SPI_Cmd
;;;264    }
00005c  b005              ADD      sp,sp,#0x14
00005e  bd00              POP      {pc}
;;;265    
                          ENDP

                  |L1.96|
                          DCD      0x40013000

                          AREA ||i.bsp_InitSFlash||, CODE, READONLY, ALIGN=2

                  bsp_InitSFlash PROC
;;;128    */
;;;129    void bsp_InitSFlash(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;130    {
;;;131    
;;;132    #ifdef STM32_X3		/* 安富莱 STM32-X3 开发板 */
;;;133    	/*
;;;134    		安富莱STM32-X4 口线分配： 串行Flash型号为 W25Q64BVSSIG (80MHz)
;;;135    		PB12 = CS
;;;136    		PB13 = SCK
;;;137    		PB14 = MISO
;;;138    		PB15 = MOSI
;;;139    
;;;140    		STM32硬件SPI接口 = SPI2
;;;141    	*/
;;;142    	{
;;;143    		GPIO_InitTypeDef GPIO_InitStructure;
;;;144    
;;;145    		/* 使能GPIO 时钟 */
;;;146    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;147    
;;;148    		/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;149    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
;;;150    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_SPI2);
;;;151    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);
;;;152    
;;;153    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;154    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;155    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;156    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
;;;157    
;;;158    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;
;;;159    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;160    
;;;161    		/* 配置片选口线为推挽输出模式 */
;;;162    		SF_CS_HIGH();		/* 片选置高，不选中 */
;;;163    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;164    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;165    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;166    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;167    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;168    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;169    	}
;;;170    #else
;;;171    	/*
;;;172    		安富莱STM32-V5 开发板口线分配：  串行Flash型号为 W25Q64BVSSIG (80MHz)
;;;173    		PB3/SPI3_SCK
;;;174    		PB4/SPI3_MISO
;;;175    		PB5/SPI3_MOSI
;;;176    		PF8/SF_CS
;;;177    
;;;178    		STM32硬件SPI接口 = SPI3
;;;179    	*/
;;;180    	{
;;;181    		GPIO_InitTypeDef GPIO_InitStructure;
;;;182    
;;;183    		/* 使能GPIO 时钟 */
;;;184    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOF, ENABLE);
000002  2101              MOVS     r1,#1
000004  2022              MOVS     r0,#0x22
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;185    
;;;186    		/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;187    		//GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI3);
;;;188    		//GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI3);
;;;189    		//GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI3);
;;;190    		/* 配置 SCK, MISO 、 MOSI 为复用功能 */
;;;191    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);
00000a  2205              MOVS     r2,#5
00000c  2103              MOVS     r1,#3
00000e  4825              LDR      r0,|L2.164|
000010  f7fffffe          BL       GPIO_PinAFConfig
;;;192    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);
000014  2205              MOVS     r2,#5
000016  2104              MOVS     r1,#4
000018  4822              LDR      r0,|L2.164|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;193    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);
00001e  2205              MOVS     r2,#5
000020  4611              MOV      r1,r2
000022  4820              LDR      r0,|L2.164|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;194    
;;;195    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000028  2002              MOVS     r0,#2
00002a  f88d0004          STRB     r0,[sp,#4]
;;;196    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002e  f88d0005          STRB     r0,[sp,#5]
;;;197    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000032  2000              MOVS     r0,#0
000034  f88d0006          STRB     r0,[sp,#6]
;;;198    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
000038  2002              MOVS     r0,#2
00003a  f88d0007          STRB     r0,[sp,#7]
;;;199    
;;;200    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
00003e  2038              MOVS     r0,#0x38
000040  9000              STR      r0,[sp,#0]
;;;201    		GPIO_Init(GPIOB, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4817              LDR      r0,|L2.164|
000046  f7fffffe          BL       GPIO_Init
;;;202    
;;;203    		/* 配置片选口线为推挽输出模式 */
;;;204    		SF_CS_HIGH();		/* 片选置高，不选中 */
00004a  f44f7080          MOV      r0,#0x100
00004e  4916              LDR      r1,|L2.168|
000050  8008              STRH     r0,[r1,#0]
;;;205    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000052  2001              MOVS     r0,#1
000054  f88d0004          STRB     r0,[sp,#4]
;;;206    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000058  2000              MOVS     r0,#0
00005a  f88d0006          STRB     r0,[sp,#6]
;;;207    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00005e  2002              MOVS     r0,#2
000060  f88d0005          STRB     r0,[sp,#5]
;;;208    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000064  2000              MOVS     r0,#0
000066  f88d0007          STRB     r0,[sp,#7]
;;;209    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
00006a  1588              ASRS     r0,r1,#22
00006c  9000              STR      r0,[sp,#0]
;;;210    		GPIO_Init(GPIOF, &GPIO_InitStructure);
00006e  4669              MOV      r1,sp
000070  480d              LDR      r0,|L2.168|
000072  3818              SUBS     r0,r0,#0x18
000074  f7fffffe          BL       GPIO_Init
;;;211    	}
;;;212    #endif
;;;213    
;;;214    	/* 配置SPI硬件参数用于访问串行Flash */
;;;215    	bsp_CfgSPIForSFlash();
000078  f7fffffe          BL       bsp_CfgSPIForSFlash
;;;216    
;;;217    	sf_ReadInfo();				/* 自动识别芯片型号 */
00007c  f7fffffe          BL       sf_ReadInfo
;;;218    
;;;219    	SF_CS_LOW();				/* 软件方式，使能串行Flash片选 */
000080  f44f7080          MOV      r0,#0x100
000084  4908              LDR      r1,|L2.168|
000086  1c89              ADDS     r1,r1,#2
000088  8008              STRH     r0,[r1,#0]
;;;220    	sf_SendByte(CMD_DISWR);		/* 发送禁止写入的命令,即使能软件写保护 */
00008a  2004              MOVS     r0,#4
00008c  f7fffffe          BL       sf_SendByte
;;;221    	SF_CS_HIGH();				/* 软件方式，禁能串行Flash片选 */
000090  f44f7080          MOV      r0,#0x100
000094  4904              LDR      r1,|L2.168|
000096  8008              STRH     r0,[r1,#0]
;;;222    
;;;223    	sf_WaitForWriteEnd();		/* 等待串行Flash内部操作完成 */
000098  f7fffffe          BL       sf_WaitForWriteEnd
;;;224    
;;;225    	sf_WriteStatus(0);			/* 解除所有BLOCK的写保护 */
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       sf_WriteStatus
;;;226    }
0000a2  bd1c              POP      {r2-r4,pc}
;;;227    
                          ENDP

                  |L2.164|
                          DCD      0x40020400
                  |L2.168|
                          DCD      0x40021418

                          AREA ||i.sf_AutoWritePage||, CODE, READONLY, ALIGN=2

                  sf_AutoWritePage PROC
;;;524    */
;;;525    static uint8_t sf_AutoWritePage(uint8_t *_ucpSrc, uint32_t _uiWrAddr, uint16_t _usWrLen)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;526    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;527    	uint16_t i;
;;;528    	uint16_t j;					/* 用于延时 */
;;;529    	uint32_t uiFirstAddr;		/* 扇区首址 */
;;;530    	uint8_t ucNeedErase;		/* 1表示需要擦除 */
;;;531    	uint8_t cRet;
;;;532    
;;;533    	/* 长度为0时不继续操作,直接认为成功 */
;;;534    	if (_usWrLen == 0)
00000a  b916              CBNZ     r6,|L3.18|
;;;535    	{
;;;536    		return 1;
00000c  2001              MOVS     r0,#1
                  |L3.14|
;;;537    	}
;;;538    
;;;539    	/* 如果偏移地址超过芯片容量则退出 */
;;;540    	if (_uiWrAddr >= g_tSF.TotalSize)
;;;541    	{
;;;542    		return 0;
;;;543    	}
;;;544    
;;;545    	/* 如果数据长度大于扇区容量，则退出 */
;;;546    	if (_usWrLen > g_tSF.PageSize)
;;;547    	{
;;;548    		return 0;
;;;549    	}
;;;550    
;;;551    	/* 如果FLASH中的数据没有变化,则不写FLASH */
;;;552    	sf_ReadBuffer(s_spiBuf, _uiWrAddr, _usWrLen);
;;;553    	if (memcmp(s_spiBuf, _ucpSrc, _usWrLen) == 0)
;;;554    	{
;;;555    		return 1;
;;;556    	}
;;;557    
;;;558    	/* 判断是否需要先擦除扇区 */
;;;559    	/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;560    	ucNeedErase = 0;
;;;561    	if (sf_NeedErase(s_spiBuf, _ucpSrc, _usWrLen))
;;;562    	{
;;;563    		ucNeedErase = 1;
;;;564    	}
;;;565    
;;;566    	uiFirstAddr = _uiWrAddr & (~(g_tSF.PageSize - 1));
;;;567    
;;;568    	if (_usWrLen == g_tSF.PageSize)		/* 整个扇区都改写 */
;;;569    	{
;;;570    		for	(i = 0; i < g_tSF.PageSize; i++)
;;;571    		{
;;;572    			s_spiBuf[i] = _ucpSrc[i];
;;;573    		}
;;;574    	}
;;;575    	else						/* 改写部分数据 */
;;;576    	{
;;;577    		/* 先将整个扇区的数据读出 */
;;;578    		sf_ReadBuffer(s_spiBuf, uiFirstAddr, g_tSF.PageSize);
;;;579    
;;;580    		/* 再用新数据覆盖 */
;;;581    		i = _uiWrAddr & (g_tSF.PageSize - 1);
;;;582    		memcpy(&s_spiBuf[i], _ucpSrc, _usWrLen);
;;;583    	}
;;;584    
;;;585    	/* 写完之后进行校验，如果不正确则重写，最多3次 */
;;;586    	cRet = 0;
;;;587    	for (i = 0; i < 3; i++)
;;;588    	{
;;;589    
;;;590    		/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;591    		if (ucNeedErase == 1)
;;;592    		{
;;;593    			sf_EraseSector(uiFirstAddr);		/* 擦除1个扇区 */
;;;594    		}
;;;595    
;;;596    		/* 编程一个PAGE */
;;;597    		sf_PageWrite(s_spiBuf, uiFirstAddr, g_tSF.PageSize);
;;;598    
;;;599    		if (sf_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;600    		{
;;;601    			cRet = 1;
;;;602    			break;
;;;603    		}
;;;604    		else
;;;605    		{
;;;606    			if (sf_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;607    			{
;;;608    				cRet = 1;
;;;609    				break;
;;;610    			}
;;;611    
;;;612    			/* 失败后延迟一段时间再重试 */
;;;613    			for (j = 0; j < 10000; j++);
;;;614    		}
;;;615    	}
;;;616    
;;;617    	return cRet;
;;;618    }
00000e  e8bd9ff0          POP      {r4-r12,pc}
                  |L3.18|
000012  483e              LDR      r0,|L3.268|
000014  6940              LDR      r0,[r0,#0x14]         ;540  ; g_tSF
000016  42a8              CMP      r0,r5                 ;540
000018  d801              BHI      |L3.30|
00001a  2000              MOVS     r0,#0                 ;542
00001c  e7f7              B        |L3.14|
                  |L3.30|
00001e  483b              LDR      r0,|L3.268|
000020  8b00              LDRH     r0,[r0,#0x18]         ;546  ; g_tSF
000022  42b0              CMP      r0,r6                 ;546
000024  da01              BGE      |L3.42|
000026  2000              MOVS     r0,#0                 ;548
000028  e7f1              B        |L3.14|
                  |L3.42|
00002a  4632              MOV      r2,r6                 ;552
00002c  4629              MOV      r1,r5                 ;552
00002e  4838              LDR      r0,|L3.272|
000030  f7fffffe          BL       sf_ReadBuffer
000034  4632              MOV      r2,r6                 ;553
000036  4639              MOV      r1,r7                 ;553
000038  4835              LDR      r0,|L3.272|
00003a  f7fffffe          BL       memcmp
00003e  b908              CBNZ     r0,|L3.68|
000040  2001              MOVS     r0,#1                 ;555
000042  e7e4              B        |L3.14|
                  |L3.68|
000044  f04f0a00          MOV      r10,#0                ;560
000048  4632              MOV      r2,r6                 ;561
00004a  4639              MOV      r1,r7                 ;561
00004c  4830              LDR      r0,|L3.272|
00004e  f7fffffe          BL       sf_NeedErase
000052  b108              CBZ      r0,|L3.88|
000054  f04f0a01          MOV      r10,#1                ;563
                  |L3.88|
000058  482c              LDR      r0,|L3.268|
00005a  8b00              LDRH     r0,[r0,#0x18]         ;566  ; g_tSF
00005c  1e40              SUBS     r0,r0,#1              ;566
00005e  ea250800          BIC      r8,r5,r0              ;566
000062  482a              LDR      r0,|L3.268|
000064  8b00              LDRH     r0,[r0,#0x18]         ;568  ; g_tSF
000066  42b0              CMP      r0,r6                 ;568
000068  d10b              BNE      |L3.130|
00006a  2400              MOVS     r4,#0                 ;570
00006c  e004              B        |L3.120|
                  |L3.110|
00006e  5d38              LDRB     r0,[r7,r4]            ;572
000070  4927              LDR      r1,|L3.272|
000072  5508              STRB     r0,[r1,r4]            ;572
000074  1c60              ADDS     r0,r4,#1              ;570
000076  b284              UXTH     r4,r0                 ;570
                  |L3.120|
000078  4824              LDR      r0,|L3.268|
00007a  8b00              LDRH     r0,[r0,#0x18]         ;570  ; g_tSF
00007c  42a0              CMP      r0,r4                 ;570
00007e  dcf6              BGT      |L3.110|
000080  e010              B        |L3.164|
                  |L3.130|
000082  4822              LDR      r0,|L3.268|
000084  8b02              LDRH     r2,[r0,#0x18]         ;578  ; g_tSF
000086  4641              MOV      r1,r8                 ;578
000088  4821              LDR      r0,|L3.272|
00008a  f7fffffe          BL       sf_ReadBuffer
00008e  481f              LDR      r0,|L3.268|
000090  8b00              LDRH     r0,[r0,#0x18]         ;581  ; g_tSF
000092  1e40              SUBS     r0,r0,#1              ;581
000094  4028              ANDS     r0,r0,r5              ;581
000096  b284              UXTH     r4,r0                 ;581
000098  491d              LDR      r1,|L3.272|
00009a  1908              ADDS     r0,r1,r4              ;582
00009c  4632              MOV      r2,r6                 ;582
00009e  4639              MOV      r1,r7                 ;582
0000a0  f7fffffe          BL       __aeabi_memcpy
                  |L3.164|
0000a4  f04f0b00          MOV      r11,#0                ;586
0000a8  2400              MOVS     r4,#0                 ;587
0000aa  e02a              B        |L3.258|
                  |L3.172|
0000ac  f1ba0f01          CMP      r10,#1                ;591
0000b0  d102              BNE      |L3.184|
0000b2  4640              MOV      r0,r8                 ;593
0000b4  f7fffffe          BL       sf_EraseSector
                  |L3.184|
0000b8  4814              LDR      r0,|L3.268|
0000ba  8b02              LDRH     r2,[r0,#0x18]         ;597  ; g_tSF
0000bc  4641              MOV      r1,r8                 ;597
0000be  4814              LDR      r0,|L3.272|
0000c0  f7fffffe          BL       sf_PageWrite
0000c4  4632              MOV      r2,r6                 ;599
0000c6  4639              MOV      r1,r7                 ;599
0000c8  4628              MOV      r0,r5                 ;599
0000ca  f7fffffe          BL       sf_CmpData
0000ce  b910              CBNZ     r0,|L3.214|
0000d0  f04f0b01          MOV      r11,#1                ;601
0000d4  e017              B        |L3.262|
                  |L3.214|
0000d6  4632              MOV      r2,r6                 ;606
0000d8  4639              MOV      r1,r7                 ;606
0000da  4628              MOV      r0,r5                 ;606
0000dc  f7fffffe          BL       sf_CmpData
0000e0  b910              CBNZ     r0,|L3.232|
0000e2  f04f0b01          MOV      r11,#1                ;608
0000e6  e00e              B        |L3.262|
                  |L3.232|
0000e8  f04f0900          MOV      r9,#0                 ;613
0000ec  e003              B        |L3.246|
                  |L3.238|
0000ee  f1090001          ADD      r0,r9,#1              ;613
0000f2  fa1ff980          UXTH     r9,r0                 ;613
                  |L3.246|
0000f6  f2427010          MOV      r0,#0x2710            ;613
0000fa  4581              CMP      r9,r0                 ;613
0000fc  dbf7              BLT      |L3.238|
0000fe  1c60              ADDS     r0,r4,#1              ;587
000100  b284              UXTH     r4,r0                 ;587
                  |L3.258|
000102  2c03              CMP      r4,#3                 ;587
000104  dbd2              BLT      |L3.172|
                  |L3.262|
000106  bf00              NOP                            ;602
000108  4658              MOV      r0,r11                ;617
00010a  e780              B        |L3.14|
;;;619    
                          ENDP

                  |L3.268|
                          DCD      g_tSF
                  |L3.272|
                          DCD      s_spiBuf

                          AREA ||i.sf_CmpData||, CODE, READONLY, ALIGN=2

                  sf_CmpData PROC
;;;436    */
;;;437    static uint8_t sf_CmpData(uint32_t _uiSrcAddr, uint8_t *_ucpTar, uint32_t _uiSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;438    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;439    	uint8_t ucValue;
;;;440    
;;;441    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;442    	if ((_uiSrcAddr + _uiSize) > g_tSF.TotalSize)
00000a  1960              ADDS     r0,r4,r5
00000c  491b              LDR      r1,|L4.124|
00000e  6949              LDR      r1,[r1,#0x14]  ; g_tSF
000010  4288              CMP      r0,r1
000012  d902              BLS      |L4.26|
;;;443    	{
;;;444    		return 1;
000014  2001              MOVS     r0,#1
                  |L4.22|
;;;445    	}
;;;446    
;;;447    	if (_uiSize == 0)
;;;448    	{
;;;449    		return 0;
;;;450    	}
;;;451    
;;;452    	SF_CS_LOW();									/* 使能片选 */
;;;453    	sf_SendByte(CMD_READ);							/* 发送读命令 */
;;;454    	sf_SendByte((_uiSrcAddr & 0xFF0000) >> 16);		/* 发送扇区地址的高8bit */
;;;455    	sf_SendByte((_uiSrcAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;456    	sf_SendByte(_uiSrcAddr & 0xFF);					/* 发送扇区地址低8bit */
;;;457    	while (_uiSize--)
;;;458    	{
;;;459    		/* 读一个字节 */
;;;460    		ucValue = sf_SendByte(DUMMY_BYTE);
;;;461    		if (*_ucpTar++ != ucValue)
;;;462    		{
;;;463    			SF_CS_HIGH();
;;;464    			return 1;
;;;465    		}
;;;466    	}
;;;467    	SF_CS_HIGH();
;;;468    	return 0;
;;;469    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L4.26|
00001a  b90d              CBNZ     r5,|L4.32|
00001c  2000              MOVS     r0,#0                 ;449
00001e  e7fa              B        |L4.22|
                  |L4.32|
000020  f44f7080          MOV      r0,#0x100             ;452
000024  4916              LDR      r1,|L4.128|
000026  8008              STRH     r0,[r1,#0]            ;452
000028  2003              MOVS     r0,#3                 ;453
00002a  f7fffffe          BL       sf_SendByte
00002e  f3c44007          UBFX     r0,r4,#16,#8          ;454
000032  f7fffffe          BL       sf_SendByte
000036  f3c42007          UBFX     r0,r4,#8,#8           ;455
00003a  f7fffffe          BL       sf_SendByte
00003e  b2e0              UXTB     r0,r4                 ;456
000040  f7fffffe          BL       sf_SendByte
000044  e00e              B        |L4.100|
                  |L4.70|
000046  20a5              MOVS     r0,#0xa5              ;460
000048  f7fffffe          BL       sf_SendByte
00004c  4607              MOV      r7,r0                 ;460
00004e  f8161b01          LDRB     r1,[r6],#1            ;461
000052  42b9              CMP      r1,r7                 ;461
000054  d006              BEQ      |L4.100|
000056  f44f7080          MOV      r0,#0x100             ;463
00005a  4909              LDR      r1,|L4.128|
00005c  1e89              SUBS     r1,r1,#2              ;463
00005e  8008              STRH     r0,[r1,#0]            ;463
000060  2001              MOVS     r0,#1                 ;464
000062  e7d8              B        |L4.22|
                  |L4.100|
000064  0028              MOVS     r0,r5                 ;457
000066  f1a50501          SUB      r5,r5,#1              ;457
00006a  d1ec              BNE      |L4.70|
00006c  f44f7080          MOV      r0,#0x100             ;467
000070  4903              LDR      r1,|L4.128|
000072  1e89              SUBS     r1,r1,#2              ;467
000074  8008              STRH     r0,[r1,#0]            ;467
000076  2000              MOVS     r0,#0                 ;468
000078  e7cd              B        |L4.22|
;;;470    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      g_tSF
                  |L4.128|
                          DCD      0x4002141a

                          AREA ||i.sf_EraseChip||, CODE, READONLY, ALIGN=2

                  sf_EraseChip PROC
;;;296    */
;;;297    void sf_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;298    {
;;;299    	sf_WriteEnable();								/* 发送写使能命令 */
000002  f7fffffe          BL       sf_WriteEnable
;;;300    
;;;301    	/* 擦除扇区操作 */
;;;302    	SF_CS_LOW();									/* 使能片选 */
000006  f44f7080          MOV      r0,#0x100
00000a  4906              LDR      r1,|L5.36|
00000c  8008              STRH     r0,[r1,#0]
;;;303    	sf_SendByte(CMD_BE);							/* 发送整片擦除命令 */
00000e  20c7              MOVS     r0,#0xc7
000010  f7fffffe          BL       sf_SendByte
;;;304    	SF_CS_HIGH();									/* 禁能片选 */
000014  f44f7080          MOV      r0,#0x100
000018  4902              LDR      r1,|L5.36|
00001a  1e89              SUBS     r1,r1,#2
00001c  8008              STRH     r0,[r1,#0]
;;;305    
;;;306    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
00001e  f7fffffe          BL       sf_WaitForWriteEnd
;;;307    }
000022  bd10              POP      {r4,pc}
;;;308    
                          ENDP

                  |L5.36|
                          DCD      0x4002141a

                          AREA ||i.sf_EraseSector||, CODE, READONLY, ALIGN=2

                  sf_EraseSector PROC
;;;273    */
;;;274    void sf_EraseSector(uint32_t _uiSectorAddr)
000000  b510              PUSH     {r4,lr}
;;;275    {
000002  4604              MOV      r4,r0
;;;276    	sf_WriteEnable();								/* 发送写使能命令 */
000004  f7fffffe          BL       sf_WriteEnable
;;;277    
;;;278    	/* 擦除扇区操作 */
;;;279    	SF_CS_LOW();									/* 使能片选 */
000008  f44f7080          MOV      r0,#0x100
00000c  490b              LDR      r1,|L6.60|
00000e  8008              STRH     r0,[r1,#0]
;;;280    	sf_SendByte(CMD_SE);								/* 发送擦除命令 */
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       sf_SendByte
;;;281    	sf_SendByte((_uiSectorAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       sf_SendByte
;;;282    	sf_SendByte((_uiSectorAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       sf_SendByte
;;;283    	sf_SendByte(_uiSectorAddr & 0xFF);				/* 发送扇区地址低8bit */
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       sf_SendByte
;;;284    	SF_CS_HIGH();									/* 禁能片选 */
00002c  f44f7080          MOV      r0,#0x100
000030  4902              LDR      r1,|L6.60|
000032  1e89              SUBS     r1,r1,#2
000034  8008              STRH     r0,[r1,#0]
;;;285    
;;;286    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000036  f7fffffe          BL       sf_WaitForWriteEnd
;;;287    }
00003a  bd10              POP      {r4,pc}
;;;288    
                          ENDP

                  |L6.60|
                          DCD      0x4002141a

                          AREA ||i.sf_NeedErase||, CODE, READONLY, ALIGN=1

                  sf_NeedErase PROC
;;;480    */
;;;481    static uint8_t sf_NeedErase(uint8_t * _ucpOldBuf, uint8_t *_ucpNewBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4603              MOV      r3,r0
;;;483    	uint16_t i;
;;;484    	uint8_t ucOld;
;;;485    
;;;486    	/*
;;;487    	算法第1步：old 求反, new 不变
;;;488    	      old    new
;;;489    		  1101   0101
;;;490    	~     1111
;;;491    		= 0010   0101
;;;492    
;;;493    	算法第2步: old 求反的结果与 new 位与
;;;494    		  0010   old
;;;495    	&	  0101   new
;;;496    		 =0000
;;;497    
;;;498    	算法第3步: 结果为0,则表示无需擦除. 否则表示需要擦除
;;;499    	*/
;;;500    
;;;501    	for (i = 0; i < _usLen; i++)
000004  2400              MOVS     r4,#0
000006  e00b              B        |L7.32|
                  |L7.8|
;;;502    	{
;;;503    		ucOld = *_ucpOldBuf++;
000008  f8135b01          LDRB     r5,[r3],#1
;;;504    		ucOld = ~ucOld;
00000c  43e8              MVNS     r0,r5
00000e  b2c5              UXTB     r5,r0
;;;505    
;;;506    		/* 注意错误的写法: if (ucOld & (*_ucpNewBuf++) != 0) */
;;;507    		if ((ucOld & (*_ucpNewBuf++)) != 0)
000010  f8110b01          LDRB     r0,[r1],#1
000014  4228              TST      r0,r5
000016  d001              BEQ      |L7.28|
;;;508    		{
;;;509    			return 1;
000018  2001              MOVS     r0,#1
                  |L7.26|
;;;510    		}
;;;511    	}
;;;512    	return 0;
;;;513    }
00001a  bd70              POP      {r4-r6,pc}
                  |L7.28|
00001c  1c60              ADDS     r0,r4,#1              ;501
00001e  b284              UXTH     r4,r0                 ;501
                  |L7.32|
000020  4294              CMP      r4,r2                 ;501
000022  dbf1              BLT      |L7.8|
000024  2000              MOVS     r0,#0                 ;512
000026  e7f8              B        |L7.26|
;;;514    
                          ENDP


                          AREA ||i.sf_PageWrite||, CODE, READONLY, ALIGN=2

                  sf_PageWrite PROC
;;;318    */
;;;319    void sf_PageWrite(uint8_t * _pBuf, uint32_t _uiWriteAddr, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;320    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;321    	uint32_t i, j;
;;;322    
;;;323    	if (g_tSF.ChipID == SST25VF016B_ID)
00000a  4851              LDR      r0,|L8.336|
00000c  6800              LDR      r0,[r0,#0]  ; g_tSF
00000e  4951              LDR      r1,|L8.340|
000010  4288              CMP      r0,r1
000012  d15c              BNE      |L8.206|
;;;324    	{
;;;325    		/* AAI指令要求传入的数据个数是偶数 */
;;;326    		if ((_usSize < 2) && (_usSize % 2))
000014  2d02              CMP      r5,#2
000016  da08              BGE      |L8.42|
000018  4628              MOV      r0,r5
00001a  eb0571d0          ADD      r1,r5,r0,LSR #31
00001e  1049              ASRS     r1,r1,#1
000020  ebb50141          SUBS     r1,r5,r1,LSL #1
000024  d001              BEQ      |L8.42|
                  |L8.38|
;;;327    		{
;;;328    			return ;
;;;329    		}
;;;330    
;;;331    		sf_WriteEnable();								/* 发送写使能命令 */
;;;332    
;;;333    		SF_CS_LOW();									/* 使能片选 */
;;;334    		sf_SendByte(CMD_AAI);							/* 发送AAI命令(地址自动增加编程) */
;;;335    		sf_SendByte((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;336    		sf_SendByte((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;337    		sf_SendByte(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
;;;338    		sf_SendByte(*_pBuf++);							/* 发送第1个数据 */
;;;339    		sf_SendByte(*_pBuf++);							/* 发送第2个数据 */
;;;340    		SF_CS_HIGH();									/* 禁能片选 */
;;;341    
;;;342    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;343    
;;;344    		_usSize -= 2;									/* 计算剩余字节数 */
;;;345    
;;;346    		for (i = 0; i < _usSize / 2; i++)
;;;347    		{
;;;348    			SF_CS_LOW();								/* 使能片选 */
;;;349    			sf_SendByte(CMD_AAI);						/* 发送AAI命令(地址自动增加编程) */
;;;350    			sf_SendByte(*_pBuf++);						/* 发送数据 */
;;;351    			sf_SendByte(*_pBuf++);						/* 发送数据 */
;;;352    			SF_CS_HIGH();								/* 禁能片选 */
;;;353    			sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
;;;354    		}
;;;355    
;;;356    		/* 进入写保护状态 */
;;;357    		SF_CS_LOW();
;;;358    		sf_SendByte(CMD_DISWR);
;;;359    		SF_CS_HIGH();
;;;360    
;;;361    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;362    	}
;;;363    	else	/* for MX25L1606E 、 W25Q64BV */
;;;364    	{
;;;365    		for (j = 0; j < _usSize / 256; j++)
;;;366    		{
;;;367    			sf_WriteEnable();								/* 发送写使能命令 */
;;;368    
;;;369    			SF_CS_LOW();									/* 使能片选 */
;;;370    			sf_SendByte(0x02);								/* 发送AAI命令(地址自动增加编程) */
;;;371    			sf_SendByte((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;372    			sf_SendByte((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;373    			sf_SendByte(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
;;;374    
;;;375    			for (i = 0; i < 256; i++)
;;;376    			{
;;;377    				sf_SendByte(*_pBuf++);					/* 发送数据 */
;;;378    			}
;;;379    
;;;380    			SF_CS_HIGH();								/* 禁止片选 */
;;;381    
;;;382    			sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
;;;383    
;;;384    			_uiWriteAddr += 256;
;;;385    		}
;;;386    
;;;387    		/* 进入写保护状态 */
;;;388    		SF_CS_LOW();
;;;389    		sf_SendByte(CMD_DISWR);
;;;390    		SF_CS_HIGH();
;;;391    
;;;392    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;393    	}
;;;394    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L8.42|
00002a  f7fffffe          BL       sf_WriteEnable
00002e  f44f7080          MOV      r0,#0x100             ;333
000032  4949              LDR      r1,|L8.344|
000034  8008              STRH     r0,[r1,#0]            ;333
000036  20ad              MOVS     r0,#0xad              ;334
000038  f7fffffe          BL       sf_SendByte
00003c  f3c64007          UBFX     r0,r6,#16,#8          ;335
000040  f7fffffe          BL       sf_SendByte
000044  f3c62007          UBFX     r0,r6,#8,#8           ;336
000048  f7fffffe          BL       sf_SendByte
00004c  b2f0              UXTB     r0,r6                 ;337
00004e  f7fffffe          BL       sf_SendByte
000052  f8140b01          LDRB     r0,[r4],#1            ;338
000056  f7fffffe          BL       sf_SendByte
00005a  f8140b01          LDRB     r0,[r4],#1            ;339
00005e  f7fffffe          BL       sf_SendByte
000062  f44f7080          MOV      r0,#0x100             ;340
000066  493c              LDR      r1,|L8.344|
000068  1e89              SUBS     r1,r1,#2              ;340
00006a  8008              STRH     r0,[r1,#0]            ;340
00006c  f7fffffe          BL       sf_WaitForWriteEnd
000070  1ea8              SUBS     r0,r5,#2              ;344
000072  b285              UXTH     r5,r0                 ;344
000074  2700              MOVS     r7,#0                 ;346
000076  e016              B        |L8.166|
                  |L8.120|
000078  f44f7080          MOV      r0,#0x100             ;348
00007c  4936              LDR      r1,|L8.344|
00007e  8008              STRH     r0,[r1,#0]            ;348
000080  20ad              MOVS     r0,#0xad              ;349
000082  f7fffffe          BL       sf_SendByte
000086  f8140b01          LDRB     r0,[r4],#1            ;350
00008a  f7fffffe          BL       sf_SendByte
00008e  f8140b01          LDRB     r0,[r4],#1            ;351
000092  f7fffffe          BL       sf_SendByte
000096  f44f7080          MOV      r0,#0x100             ;352
00009a  492f              LDR      r1,|L8.344|
00009c  1e89              SUBS     r1,r1,#2              ;352
00009e  8008              STRH     r0,[r1,#0]            ;352
0000a0  f7fffffe          BL       sf_WaitForWriteEnd
0000a4  1c7f              ADDS     r7,r7,#1              ;346
                  |L8.166|
0000a6  eb0571d5          ADD      r1,r5,r5,LSR #31      ;346
0000aa  ebb70f61          CMP      r7,r1,ASR #1          ;346
0000ae  d3e3              BCC      |L8.120|
0000b0  f44f7080          MOV      r0,#0x100             ;357
0000b4  4928              LDR      r1,|L8.344|
0000b6  8008              STRH     r0,[r1,#0]            ;357
0000b8  2004              MOVS     r0,#4                 ;358
0000ba  f7fffffe          BL       sf_SendByte
0000be  f44f7080          MOV      r0,#0x100             ;359
0000c2  4925              LDR      r1,|L8.344|
0000c4  1e89              SUBS     r1,r1,#2              ;359
0000c6  8008              STRH     r0,[r1,#0]            ;359
0000c8  f7fffffe          BL       sf_WaitForWriteEnd
0000cc  e03e              B        |L8.332|
                  |L8.206|
0000ce  f04f0800          MOV      r8,#0                 ;365
0000d2  e027              B        |L8.292|
                  |L8.212|
0000d4  f7fffffe          BL       sf_WriteEnable
0000d8  f44f7080          MOV      r0,#0x100             ;369
0000dc  491e              LDR      r1,|L8.344|
0000de  8008              STRH     r0,[r1,#0]            ;369
0000e0  2002              MOVS     r0,#2                 ;370
0000e2  f7fffffe          BL       sf_SendByte
0000e6  f3c64007          UBFX     r0,r6,#16,#8          ;371
0000ea  f7fffffe          BL       sf_SendByte
0000ee  f3c62007          UBFX     r0,r6,#8,#8           ;372
0000f2  f7fffffe          BL       sf_SendByte
0000f6  b2f0              UXTB     r0,r6                 ;373
0000f8  f7fffffe          BL       sf_SendByte
0000fc  2700              MOVS     r7,#0                 ;375
0000fe  e004              B        |L8.266|
                  |L8.256|
000100  f8140b01          LDRB     r0,[r4],#1            ;377
000104  f7fffffe          BL       sf_SendByte
000108  1c7f              ADDS     r7,r7,#1              ;375
                  |L8.266|
00010a  2fff              CMP      r7,#0xff              ;375
00010c  d9f8              BLS      |L8.256|
00010e  f44f7080          MOV      r0,#0x100             ;380
000112  4911              LDR      r1,|L8.344|
000114  1e89              SUBS     r1,r1,#2              ;380
000116  8008              STRH     r0,[r1,#0]            ;380
000118  f7fffffe          BL       sf_WaitForWriteEnd
00011c  f5067680          ADD      r6,r6,#0x100          ;384
000120  f1080801          ADD      r8,r8,#1              ;365
                  |L8.292|
000124  17e9              ASRS     r1,r5,#31             ;365
000126  eb056111          ADD      r1,r5,r1,LSR #24      ;365
00012a  ebb82f21          CMP      r8,r1,ASR #8          ;365
00012e  d3d1              BCC      |L8.212|
000130  f44f7080          MOV      r0,#0x100             ;388
000134  4908              LDR      r1,|L8.344|
000136  8008              STRH     r0,[r1,#0]            ;388
000138  2004              MOVS     r0,#4                 ;389
00013a  f7fffffe          BL       sf_SendByte
00013e  f44f7080          MOV      r0,#0x100             ;390
000142  4905              LDR      r1,|L8.344|
000144  1e89              SUBS     r1,r1,#2              ;390
000146  8008              STRH     r0,[r1,#0]            ;390
000148  f7fffffe          BL       sf_WaitForWriteEnd
                  |L8.332|
00014c  bf00              NOP      
00014e  e76a              B        |L8.38|
;;;395    
                          ENDP

                  |L8.336|
                          DCD      g_tSF
                  |L8.340|
                          DCD      0x00bf2541
                  |L8.344|
                          DCD      0x4002141a

                          AREA ||i.sf_ReadBuffer||, CODE, READONLY, ALIGN=2

                  sf_ReadBuffer PROC
;;;405    */
;;;406    void sf_ReadBuffer(uint8_t * _pBuf, uint32_t _uiReadAddr, uint32_t _uiSize)
000000  b570              PUSH     {r4-r6,lr}
;;;407    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;408    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;409    	if ((_uiSize == 0) ||(_uiReadAddr + _uiSize) > g_tSF.TotalSize)
000008  b125              CBZ      r5,|L9.20|
00000a  1960              ADDS     r0,r4,r5
00000c  4913              LDR      r1,|L9.92|
00000e  6949              LDR      r1,[r1,#0x14]  ; g_tSF
000010  4288              CMP      r0,r1
000012  d900              BLS      |L9.22|
                  |L9.20|
;;;410    	{
;;;411    		return;
;;;412    	}
;;;413    
;;;414    	/* 擦除扇区操作 */
;;;415    	SF_CS_LOW();									/* 使能片选 */
;;;416    	sf_SendByte(CMD_READ);							/* 发送读命令 */
;;;417    	sf_SendByte((_uiReadAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;418    	sf_SendByte((_uiReadAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;419    	sf_SendByte(_uiReadAddr & 0xFF);				/* 发送扇区地址低8bit */
;;;420    	while (_uiSize--)
;;;421    	{
;;;422    		*_pBuf++ = sf_SendByte(DUMMY_BYTE);			/* 读一个字节并存储到pBuf，读完后指针自加1 */
;;;423    	}
;;;424    	SF_CS_HIGH();									/* 禁能片选 */
;;;425    }
000014  bd70              POP      {r4-r6,pc}
                  |L9.22|
000016  f44f7080          MOV      r0,#0x100             ;415
00001a  4911              LDR      r1,|L9.96|
00001c  8008              STRH     r0,[r1,#0]            ;415
00001e  2003              MOVS     r0,#3                 ;416
000020  f7fffffe          BL       sf_SendByte
000024  f3c44007          UBFX     r0,r4,#16,#8          ;417
000028  f7fffffe          BL       sf_SendByte
00002c  f3c42007          UBFX     r0,r4,#8,#8           ;418
000030  f7fffffe          BL       sf_SendByte
000034  b2e0              UXTB     r0,r4                 ;419
000036  f7fffffe          BL       sf_SendByte
00003a  e004              B        |L9.70|
                  |L9.60|
00003c  20a5              MOVS     r0,#0xa5              ;422
00003e  f7fffffe          BL       sf_SendByte
000042  f8060b01          STRB     r0,[r6],#1            ;422
                  |L9.70|
000046  0028              MOVS     r0,r5                 ;420
000048  f1a50501          SUB      r5,r5,#1              ;420
00004c  d1f6              BNE      |L9.60|
00004e  f44f7080          MOV      r0,#0x100             ;424
000052  4903              LDR      r1,|L9.96|
000054  1e89              SUBS     r1,r1,#2              ;424
000056  8008              STRH     r0,[r1,#0]            ;424
000058  bf00              NOP      
00005a  e7db              B        |L9.20|
;;;426    
                          ENDP

                  |L9.92|
                          DCD      g_tSF
                  |L9.96|
                          DCD      0x4002141a

                          AREA ||i.sf_ReadID||, CODE, READONLY, ALIGN=2

                  sf_ReadID PROC
;;;737    */
;;;738    uint32_t sf_ReadID(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;739    {
;;;740    	uint32_t uiID;
;;;741    	uint8_t id1, id2, id3;
;;;742    
;;;743    	SF_CS_LOW();									/* 使能片选 */
000004  f44f7080          MOV      r0,#0x100
000008  490e              LDR      r1,|L10.68|
00000a  8008              STRH     r0,[r1,#0]
;;;744    	sf_SendByte(CMD_RDID);								/* 发送读ID命令 */
00000c  209f              MOVS     r0,#0x9f
00000e  f7fffffe          BL       sf_SendByte
;;;745    	id1 = sf_SendByte(DUMMY_BYTE);					/* 读ID的第1个字节 */
000012  20a5              MOVS     r0,#0xa5
000014  f7fffffe          BL       sf_SendByte
000018  4605              MOV      r5,r0
;;;746    	id2 = sf_SendByte(DUMMY_BYTE);					/* 读ID的第2个字节 */
00001a  20a5              MOVS     r0,#0xa5
00001c  f7fffffe          BL       sf_SendByte
000020  4606              MOV      r6,r0
;;;747    	id3 = sf_SendByte(DUMMY_BYTE);					/* 读ID的第3个字节 */
000022  20a5              MOVS     r0,#0xa5
000024  f7fffffe          BL       sf_SendByte
000028  4607              MOV      r7,r0
;;;748    	SF_CS_HIGH();									/* 禁能片选 */
00002a  f44f7080          MOV      r0,#0x100
00002e  4905              LDR      r1,|L10.68|
000030  1e89              SUBS     r1,r1,#2
000032  8008              STRH     r0,[r1,#0]
;;;749    
;;;750    	uiID = ((uint32_t)id1 << 16) | ((uint32_t)id2 << 8) | id3;
000034  0428              LSLS     r0,r5,#16
000036  ea402006          ORR      r0,r0,r6,LSL #8
00003a  ea400407          ORR      r4,r0,r7
;;;751    
;;;752    	return uiID;
00003e  4620              MOV      r0,r4
;;;753    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;754    
                          ENDP

                  |L10.68|
                          DCD      0x4002141a

                          AREA ||i.sf_ReadInfo||, CODE, READONLY, ALIGN=2

                  sf_ReadInfo PROC
;;;762    */
;;;763    void sf_ReadInfo(void)
000000  b510              PUSH     {r4,lr}
;;;764    {
;;;765    	/* 自动识别串行Flash型号 */
;;;766    	{
;;;767    		g_tSF.ChipID = sf_ReadID();	/* 芯片ID */
000002  f7fffffe          BL       sf_ReadID
000006  4920              LDR      r1,|L11.136|
000008  6008              STR      r0,[r1,#0]  ; g_tSF
;;;768    
;;;769    		switch (g_tSF.ChipID)
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; g_tSF
00000e  491f              LDR      r1,|L11.140|
000010  1840              ADDS     r0,r0,r1
000012  d006              BEQ      |L11.34|
000014  491e              LDR      r1,|L11.144|
000016  1840              ADDS     r0,r0,r1
000018  d00f              BEQ      |L11.58|
00001a  491e              LDR      r1,|L11.148|
00001c  1840              ADDS     r0,r0,r1
00001e  d124              BNE      |L11.106|
000020  e017              B        |L11.82|
                  |L11.34|
;;;770    		{
;;;771    			case SST25VF016B_ID:
;;;772    				strcpy(g_tSF.ChipName, "SST25VF016B");
000022  a11d              ADR      r1,|L11.152|
000024  4818              LDR      r0,|L11.136|
000026  1d00              ADDS     r0,r0,#4
000028  f7fffffe          BL       strcpy
;;;773    				g_tSF.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
00002c  f44f1000          MOV      r0,#0x200000
000030  4915              LDR      r1,|L11.136|
000032  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;774    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000034  1240              ASRS     r0,r0,#9
000036  8308              STRH     r0,[r1,#0x18]
;;;775    				break;
000038  e023              B        |L11.130|
                  |L11.58|
;;;776    
;;;777    			case MX25L1606E_ID:
;;;778    				strcpy(g_tSF.ChipName, "MX25L1606E");
00003a  a11a              ADR      r1,|L11.164|
00003c  4812              LDR      r0,|L11.136|
00003e  1d00              ADDS     r0,r0,#4
000040  f7fffffe          BL       strcpy
;;;779    				g_tSF.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
000044  f44f1000          MOV      r0,#0x200000
000048  490f              LDR      r1,|L11.136|
00004a  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;780    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
00004c  1240              ASRS     r0,r0,#9
00004e  8308              STRH     r0,[r1,#0x18]
;;;781    				break;
000050  e017              B        |L11.130|
                  |L11.82|
;;;782    
;;;783    			case W25Q64BV_ID:
;;;784    				strcpy(g_tSF.ChipName, "W25Q64BV");
000052  a117              ADR      r1,|L11.176|
000054  480c              LDR      r0,|L11.136|
000056  1d00              ADDS     r0,r0,#4
000058  f7fffffe          BL       strcpy
;;;785    				g_tSF.TotalSize = 8 * 1024 * 1024;	/* 总容量 = 8M */
00005c  f44f0000          MOV      r0,#0x800000
000060  4909              LDR      r1,|L11.136|
000062  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;786    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000064  12c0              ASRS     r0,r0,#11
000066  8308              STRH     r0,[r1,#0x18]
;;;787    				break;
000068  e00b              B        |L11.130|
                  |L11.106|
;;;788    
;;;789    			default:
;;;790    				strcpy(g_tSF.ChipName, "Unknow Flash");
00006a  a114              ADR      r1,|L11.188|
00006c  4806              LDR      r0,|L11.136|
00006e  1d00              ADDS     r0,r0,#4
000070  f7fffffe          BL       strcpy
;;;791    				g_tSF.TotalSize = 2 * 1024 * 1024;
000074  f44f1000          MOV      r0,#0x200000
000078  4903              LDR      r1,|L11.136|
00007a  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;792    				g_tSF.PageSize = 4 * 1024;
00007c  1240              ASRS     r0,r0,#9
00007e  8308              STRH     r0,[r1,#0x18]
;;;793    				break;
000080  bf00              NOP      
                  |L11.130|
000082  bf00              NOP                            ;775
;;;794    		}
;;;795    	}
;;;796    }
000084  bd10              POP      {r4,pc}
;;;797    
                          ENDP

000086  0000              DCW      0x0000
                  |L11.136|
                          DCD      g_tSF
                  |L11.140|
                          DCD      0xff40dabf
                  |L11.144|
                          DCD      0xfffd052c
                  |L11.148|
                          DCD      0xffd2dffe
                  |L11.152|
000098  53535432          DCB      "SST25VF016B",0
00009c  35564630
0000a0  31364200
                  |L11.164|
0000a4  4d583235          DCB      "MX25L1606E",0
0000a8  4c313630
0000ac  364500  
0000af  00                DCB      0
                  |L11.176|
0000b0  57323551          DCB      "W25Q64BV",0
0000b4  36344256
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L11.188|
0000bc  556e6b6e          DCB      "Unknow Flash",0
0000c0  6f772046
0000c4  6c617368
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.sf_SendByte||, CODE, READONLY, ALIGN=2

                  sf_SendByte PROC
;;;805    */
;;;806    static uint8_t sf_SendByte(uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;807    {
000002  4604              MOV      r4,r0
;;;808    	/* 等待上个数据未发送完毕 */
;;;809    	while (SPI_I2S_GetFlagStatus(SPI_FLASH, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L12.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L12.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L12.6|
;;;810    
;;;811    	/* 通过SPI硬件发送1个字节 */
;;;812    	SPI_I2S_SendData(SPI_FLASH, _ucValue);
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L12.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;813    
;;;814    	/* 等待接收一个字节任务完成 */
;;;815    	while (SPI_I2S_GetFlagStatus(SPI_FLASH, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L12.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L12.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L12.28|
;;;816    
;;;817    	/* 返回从SPI总线读到的数据 */
;;;818    	return SPI_I2S_ReceiveData(SPI_FLASH);
000028  4802              LDR      r0,|L12.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;819    }
000030  bd10              POP      {r4,pc}
;;;820    
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      0x40013000

                          AREA ||i.sf_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  sf_WaitForWriteEnd PROC
;;;876    */
;;;877    static void sf_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;878    {
;;;879    	SF_CS_LOW();									/* 使能片选 */
000002  f44f7080          MOV      r0,#0x100
000006  4909              LDR      r1,|L13.44|
000008  8008              STRH     r0,[r1,#0]
;;;880    	sf_SendByte(CMD_RDSR);							/* 发送命令， 读状态寄存器 */
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       sf_SendByte
;;;881    	while((sf_SendByte(DUMMY_BYTE) & WIP_FLAG) == SET);	/* 判断状态寄存器的忙标志位 */
000010  bf00              NOP      
                  |L13.18|
000012  20a5              MOVS     r0,#0xa5
000014  f7fffffe          BL       sf_SendByte
000018  f0100f01          TST      r0,#1
00001c  d1f9              BNE      |L13.18|
;;;882    	SF_CS_HIGH();									/* 禁能片选 */
00001e  f44f7080          MOV      r0,#0x100
000022  4902              LDR      r1,|L13.44|
000024  1e89              SUBS     r1,r1,#2
000026  8008              STRH     r0,[r1,#0]
;;;883    }
000028  bd10              POP      {r4,pc}
;;;884    
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      0x4002141a

                          AREA ||i.sf_WriteBuffer||, CODE, READONLY, ALIGN=2

                  sf_WriteBuffer PROC
;;;629    */
;;;630    uint8_t sf_WriteBuffer(uint8_t* _pBuf, uint32_t _uiWriteAddr, uint16_t _usWriteSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;631    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;632    	uint16_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
00000a  f04f0800          MOV      r8,#0
00000e  46c1              MOV      r9,r8
000010  46c2              MOV      r10,r8
000012  2400              MOVS     r4,#0
000014  46a3              MOV      r11,r4
;;;633    
;;;634    	Addr = _uiWriteAddr % g_tSF.PageSize;
000016  4856              LDR      r0,|L14.368|
000018  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
00001a  fbb5f1f0          UDIV     r1,r5,r0
00001e  fb005011          MLS      r0,r0,r1,r5
000022  fa1ffa80          UXTH     r10,r0
;;;635    	count = g_tSF.PageSize - Addr;
000026  4852              LDR      r0,|L14.368|
000028  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
00002a  eba0000a          SUB      r0,r0,r10
00002e  b284              UXTH     r4,r0
;;;636    	NumOfPage =  _usWriteSize / g_tSF.PageSize;
000030  484f              LDR      r0,|L14.368|
000032  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
000034  fb96f0f0          SDIV     r0,r6,r0
000038  fa1ff880          UXTH     r8,r0
;;;637    	NumOfSingle = _usWriteSize % g_tSF.PageSize;
00003c  484c              LDR      r0,|L14.368|
00003e  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
000040  fb96f1f0          SDIV     r1,r6,r0
000044  fb006011          MLS      r0,r0,r1,r6
000048  fa1ff980          UXTH     r9,r0
;;;638    
;;;639    	if (Addr == 0) /* 起始地址是页面首地址  */
00004c  f1ba0f00          CMP      r10,#0
000050  d12a              BNE      |L14.168|
;;;640    	{
;;;641    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
000052  f1b80f00          CMP      r8,#0
000056  d108              BNE      |L14.106|
;;;642    		{
;;;643    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
000058  4632              MOV      r2,r6
00005a  4629              MOV      r1,r5
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       sf_AutoWritePage
000062  2800              CMP      r0,#0
000064  d17e              BNE      |L14.356|
                  |L14.102|
;;;644    			{
;;;645    				return 0;
;;;646    			}
;;;647    		}
;;;648    		else 	/* 数据长度大于等于页面大小 */
;;;649    		{
;;;650    			while (NumOfPage--)
;;;651    			{
;;;652    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, g_tSF.PageSize) == 0)
;;;653    				{
;;;654    					return 0;
;;;655    				}
;;;656    				_uiWriteAddr +=  g_tSF.PageSize;
;;;657    				_pBuf += g_tSF.PageSize;
;;;658    			}
;;;659    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;660    			{
;;;661    				return 0;
;;;662    			}
;;;663    		}
;;;664    	}
;;;665    	else  /* 起始地址不是页面首地址  */
;;;666    	{
;;;667    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
;;;668    		{
;;;669    			if (NumOfSingle > count) /* (_usWriteSize + _uiWriteAddr) > SPI_FLASH_PAGESIZE */
;;;670    			{
;;;671    				temp = NumOfSingle - count;
;;;672    
;;;673    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;674    				{
;;;675    					return 0;
;;;676    				}
;;;677    
;;;678    				_uiWriteAddr +=  count;
;;;679    				_pBuf += count;
;;;680    
;;;681    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, temp) == 0)
;;;682    				{
;;;683    					return 0;
;;;684    				}
;;;685    			}
;;;686    			else
;;;687    			{
;;;688    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
;;;689    				{
;;;690    					return 0;
;;;691    				}
;;;692    			}
;;;693    		}
;;;694    		else	/* 数据长度大于等于页面大小 */
;;;695    		{
;;;696    			_usWriteSize -= count;
;;;697    			NumOfPage =  _usWriteSize / g_tSF.PageSize;
;;;698    			NumOfSingle = _usWriteSize % g_tSF.PageSize;
;;;699    
;;;700    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;701    			{
;;;702    				return 0;
;;;703    			}
;;;704    
;;;705    			_uiWriteAddr +=  count;
;;;706    			_pBuf += count;
;;;707    
;;;708    			while (NumOfPage--)
;;;709    			{
;;;710    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, g_tSF.PageSize) == 0)
;;;711    				{
;;;712    					return 0;
;;;713    				}
;;;714    				_uiWriteAddr +=  g_tSF.PageSize;
;;;715    				_pBuf += g_tSF.PageSize;
;;;716    			}
;;;717    
;;;718    			if (NumOfSingle != 0)
;;;719    			{
;;;720    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;721    				{
;;;722    					return 0;
;;;723    				}
;;;724    			}
;;;725    		}
;;;726    	}
;;;727    	return 1;	/* 成功 */
;;;728    }
000066  e8bd9ff0          POP      {r4-r12,pc}
                  |L14.106|
00006a  e00e              B        |L14.138|
                  |L14.108|
00006c  4840              LDR      r0,|L14.368|
00006e  8b02              LDRH     r2,[r0,#0x18]         ;652  ; g_tSF
000070  4629              MOV      r1,r5                 ;652
000072  4638              MOV      r0,r7                 ;652
000074  f7fffffe          BL       sf_AutoWritePage
000078  b908              CBNZ     r0,|L14.126|
00007a  2000              MOVS     r0,#0                 ;654
00007c  e7f3              B        |L14.102|
                  |L14.126|
00007e  483c              LDR      r0,|L14.368|
000080  8b00              LDRH     r0,[r0,#0x18]         ;656  ; g_tSF
000082  4405              ADD      r5,r5,r0              ;656
000084  483a              LDR      r0,|L14.368|
000086  8b00              LDRH     r0,[r0,#0x18]         ;657  ; g_tSF
000088  4407              ADD      r7,r7,r0              ;657
                  |L14.138|
00008a  ea5f0008          MOVS     r0,r8                 ;650
00008e  f1a80101          SUB      r1,r8,#1              ;650
000092  fa1ff881          UXTH     r8,r1                 ;650
000096  d1e9              BNE      |L14.108|
000098  464a              MOV      r2,r9                 ;659
00009a  4629              MOV      r1,r5                 ;659
00009c  4638              MOV      r0,r7                 ;659
00009e  f7fffffe          BL       sf_AutoWritePage
0000a2  2800              CMP      r0,#0                 ;659
0000a4  d161              BNE      |L14.362|
0000a6  e7de              B        |L14.102|
                  |L14.168|
0000a8  f1b80f00          CMP      r8,#0                 ;667
0000ac  d11f              BNE      |L14.238|
0000ae  45a1              CMP      r9,r4                 ;669
0000b0  dd15              BLE      |L14.222|
0000b2  eba90004          SUB      r0,r9,r4              ;671
0000b6  fa1ffb80          UXTH     r11,r0                ;671
0000ba  4622              MOV      r2,r4                 ;673
0000bc  4629              MOV      r1,r5                 ;673
0000be  4638              MOV      r0,r7                 ;673
0000c0  f7fffffe          BL       sf_AutoWritePage
0000c4  b908              CBNZ     r0,|L14.202|
0000c6  2000              MOVS     r0,#0                 ;675
0000c8  e7cd              B        |L14.102|
                  |L14.202|
0000ca  4425              ADD      r5,r5,r4              ;678
0000cc  4427              ADD      r7,r7,r4              ;679
0000ce  465a              MOV      r2,r11                ;681
0000d0  4629              MOV      r1,r5                 ;681
0000d2  4638              MOV      r0,r7                 ;681
0000d4  f7fffffe          BL       sf_AutoWritePage
0000d8  2800              CMP      r0,#0                 ;681
0000da  d146              BNE      |L14.362|
0000dc  e7c3              B        |L14.102|
                  |L14.222|
0000de  4632              MOV      r2,r6                 ;688
0000e0  4629              MOV      r1,r5                 ;688
0000e2  4638              MOV      r0,r7                 ;688
0000e4  f7fffffe          BL       sf_AutoWritePage
0000e8  bbe0              CBNZ     r0,|L14.356|
0000ea  2000              MOVS     r0,#0                 ;690
0000ec  e7bb              B        |L14.102|
                  |L14.238|
0000ee  1b30              SUBS     r0,r6,r4              ;696
0000f0  b286              UXTH     r6,r0                 ;696
0000f2  481f              LDR      r0,|L14.368|
0000f4  8b00              LDRH     r0,[r0,#0x18]         ;697  ; g_tSF
0000f6  fb96f0f0          SDIV     r0,r6,r0              ;697
0000fa  fa1ff880          UXTH     r8,r0                 ;697
0000fe  481c              LDR      r0,|L14.368|
000100  8b00              LDRH     r0,[r0,#0x18]         ;698  ; g_tSF
000102  fb96f1f0          SDIV     r1,r6,r0              ;698
000106  fb006011          MLS      r0,r0,r1,r6           ;698
00010a  fa1ff980          UXTH     r9,r0                 ;698
00010e  4622              MOV      r2,r4                 ;700
000110  4629              MOV      r1,r5                 ;700
000112  4638              MOV      r0,r7                 ;700
000114  f7fffffe          BL       sf_AutoWritePage
000118  b908              CBNZ     r0,|L14.286|
00011a  2000              MOVS     r0,#0                 ;702
00011c  e7a3              B        |L14.102|
                  |L14.286|
00011e  4425              ADD      r5,r5,r4              ;705
000120  4427              ADD      r7,r7,r4              ;706
000122  e00e              B        |L14.322|
                  |L14.292|
000124  4812              LDR      r0,|L14.368|
000126  8b02              LDRH     r2,[r0,#0x18]         ;710  ; g_tSF
000128  4629              MOV      r1,r5                 ;710
00012a  4638              MOV      r0,r7                 ;710
00012c  f7fffffe          BL       sf_AutoWritePage
000130  b908              CBNZ     r0,|L14.310|
000132  2000              MOVS     r0,#0                 ;712
000134  e797              B        |L14.102|
                  |L14.310|
000136  480e              LDR      r0,|L14.368|
000138  8b00              LDRH     r0,[r0,#0x18]         ;714  ; g_tSF
00013a  4405              ADD      r5,r5,r0              ;714
00013c  480c              LDR      r0,|L14.368|
00013e  8b00              LDRH     r0,[r0,#0x18]         ;715  ; g_tSF
000140  4407              ADD      r7,r7,r0              ;715
                  |L14.322|
000142  ea5f0008          MOVS     r0,r8                 ;708
000146  f1a80101          SUB      r1,r8,#1              ;708
00014a  fa1ff881          UXTH     r8,r1                 ;708
00014e  d1e9              BNE      |L14.292|
000150  f1b90f00          CMP      r9,#0                 ;718
000154  d009              BEQ      |L14.362|
000156  464a              MOV      r2,r9                 ;720
000158  4629              MOV      r1,r5                 ;720
00015a  4638              MOV      r0,r7                 ;720
00015c  f7fffffe          BL       sf_AutoWritePage
000160  b900              CBNZ     r0,|L14.356|
000162  e000              B        |L14.358|
                  |L14.356|
000164  e001              B        |L14.362|
                  |L14.358|
000166  2000              MOVS     r0,#0                 ;722
000168  e77d              B        |L14.102|
                  |L14.362|
00016a  2001              MOVS     r0,#1                 ;727
00016c  e77b              B        |L14.102|
;;;729    
                          ENDP

00016e  0000              DCW      0x0000
                  |L14.368|
                          DCD      g_tSF

                          AREA ||i.sf_WriteEnable||, CODE, READONLY, ALIGN=2

                  sf_WriteEnable PROC
;;;828    */
;;;829    static void sf_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;830    {
;;;831    	SF_CS_LOW();									/* 使能片选 */
000002  f44f7080          MOV      r0,#0x100
000006  4905              LDR      r1,|L15.28|
000008  8008              STRH     r0,[r1,#0]
;;;832    	sf_SendByte(CMD_WREN);								/* 发送命令 */
00000a  2006              MOVS     r0,#6
00000c  f7fffffe          BL       sf_SendByte
;;;833    	SF_CS_HIGH();									/* 禁能片选 */
000010  f44f7080          MOV      r0,#0x100
000014  4901              LDR      r1,|L15.28|
000016  1e89              SUBS     r1,r1,#2
000018  8008              STRH     r0,[r1,#0]
;;;834    }
00001a  bd10              POP      {r4,pc}
;;;835    
                          ENDP

                  |L15.28|
                          DCD      0x4002141a

                          AREA ||i.sf_WriteStatus||, CODE, READONLY, ALIGN=2

                  sf_WriteStatus PROC
;;;843    */
;;;844    static void sf_WriteStatus(uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;845    {
000002  4604              MOV      r4,r0
;;;846    
;;;847    	if (g_tSF.ChipID == SST25VF016B_ID)
000004  4817              LDR      r0,|L16.100|
000006  6800              LDR      r0,[r0,#0]  ; g_tSF
000008  4917              LDR      r1,|L16.104|
00000a  4288              CMP      r0,r1
00000c  d119              BNE      |L16.66|
;;;848    	{
;;;849    		/* 第1步：先使能写状态寄存器 */
;;;850    		SF_CS_LOW();									/* 使能片选 */
00000e  f44f7080          MOV      r0,#0x100
000012  4916              LDR      r1,|L16.108|
000014  8008              STRH     r0,[r1,#0]
;;;851    		sf_SendByte(CMD_EWRSR);							/* 发送命令， 允许写状态寄存器 */
000016  2050              MOVS     r0,#0x50
000018  f7fffffe          BL       sf_SendByte
;;;852    		SF_CS_HIGH();									/* 禁能片选 */
00001c  f44f7080          MOV      r0,#0x100
000020  4912              LDR      r1,|L16.108|
000022  1e89              SUBS     r1,r1,#2
000024  8008              STRH     r0,[r1,#0]
;;;853    
;;;854    		/* 第2步：再写状态寄存器 */
;;;855    		SF_CS_LOW();									/* 使能片选 */
000026  1c89              ADDS     r1,r1,#2
000028  8008              STRH     r0,[r1,#0]
;;;856    		sf_SendByte(CMD_WRSR);							/* 发送命令， 写状态寄存器 */
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       sf_SendByte
;;;857    		sf_SendByte(_ucValue);							/* 发送数据：状态寄存器的值 */
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       sf_SendByte
;;;858    		SF_CS_HIGH();									/* 禁能片选 */
000036  f44f7080          MOV      r0,#0x100
00003a  490c              LDR      r1,|L16.108|
00003c  1e89              SUBS     r1,r1,#2
00003e  8008              STRH     r0,[r1,#0]
000040  e00e              B        |L16.96|
                  |L16.66|
;;;859    	}
;;;860    	else
;;;861    	{
;;;862    		SF_CS_LOW();									/* 使能片选 */
000042  f44f7080          MOV      r0,#0x100
000046  4909              LDR      r1,|L16.108|
000048  8008              STRH     r0,[r1,#0]
;;;863    		sf_SendByte(CMD_WRSR);							/* 发送命令， 写状态寄存器 */
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       sf_SendByte
;;;864    		sf_SendByte(_ucValue);							/* 发送数据：状态寄存器的值 */
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       sf_SendByte
;;;865    		SF_CS_HIGH();									/* 禁能片选 */
000056  f44f7080          MOV      r0,#0x100
00005a  4904              LDR      r1,|L16.108|
00005c  1e89              SUBS     r1,r1,#2
00005e  8008              STRH     r0,[r1,#0]
                  |L16.96|
;;;866    	}
;;;867    }
000060  bd10              POP      {r4,pc}
;;;868    
                          ENDP

000062  0000              DCW      0x0000
                  |L16.100|
                          DCD      g_tSF
                  |L16.104|
                          DCD      0x00bf2541
                  |L16.108|
                          DCD      0x4002141a

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tSF
                          %        28
                  s_spiBuf
                          %        4096

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_flash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_77804ea8____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_spi_flash_c_77804ea8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_77804ea8____REVSH|
#line 144
|__asm___15_bsp_spi_flash_c_77804ea8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
