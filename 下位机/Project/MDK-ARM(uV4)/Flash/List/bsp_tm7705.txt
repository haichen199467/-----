; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_tm7705.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_tm7705.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_tm7705.crf ..\..\User\bsp_stm32f4xx\src\bsp_tm7705.c]
                          THUMB

                          AREA ||i.TM7705_CalibSelf||, CODE, READONLY, ALIGN=1

                  TM7705_CalibSelf PROC
;;;615    */
;;;616    void TM7705_CalibSelf(uint8_t _ch)
000000  b510              PUSH     {r4,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618    	if (_ch == 1)
000004  2c01              CMP      r4,#1
000006  d108              BNE      |L1.26|
;;;619    	{
;;;620    		/* 自校准CH1 */
;;;621    		TM7705_WriteByte(REG_SETUP | WRITE | CH_1);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       TM7705_WriteByte
;;;622    		TM7705_WriteByte(MD_CAL_SELF | __CH1_GAIN_BIPOLAR_BUF | FSYNC_0);/* 启动自校准 */
00000e  2046              MOVS     r0,#0x46
000010  f7fffffe          BL       TM7705_WriteByte
;;;623    		TM7705_WaitDRDY();	/* 等待内部操作完成 --- 时间较长，约180ms */
000014  f7fffffe          BL       TM7705_WaitDRDY
000018  e009              B        |L1.46|
                  |L1.26|
;;;624    	}
;;;625    	else if (_ch == 2)
00001a  2c02              CMP      r4,#2
00001c  d107              BNE      |L1.46|
;;;626    	{
;;;627    		/* 自校准CH2 */
;;;628    		TM7705_WriteByte(REG_SETUP | WRITE | CH_2);	/* 写通信寄存器，下一步是写设置寄存器，通道2 */
00001e  2011              MOVS     r0,#0x11
000020  f7fffffe          BL       TM7705_WriteByte
;;;629    		TM7705_WriteByte(MD_CAL_SELF | __CH2_GAIN_BIPOLAR_BUF | FSYNC_0);	/* 启动自校准 */
000024  2046              MOVS     r0,#0x46
000026  f7fffffe          BL       TM7705_WriteByte
;;;630    		TM7705_WaitDRDY();	/* 等待内部操作完成  --- 时间较长，约180ms */
00002a  f7fffffe          BL       TM7705_WaitDRDY
                  |L1.46|
;;;631    	}
;;;632    }
00002e  bd10              POP      {r4,pc}
;;;633    
                          ENDP


                          AREA ||i.TM7705_Delay||, CODE, READONLY, ALIGN=1

                  TM7705_Delay PROC
;;;283    */
;;;284    static void TM7705_Delay(void)
000000  2000              MOVS     r0,#0
;;;285    {
;;;286    	uint16_t i;
;;;287    
;;;288    	for (i = 0; i < 5; i++);
000002  e001              B        |L2.8|
                  |L2.4|
000004  1c41              ADDS     r1,r0,#1
000006  b288              UXTH     r0,r1
                  |L2.8|
000008  2805              CMP      r0,#5
00000a  dbfb              BLT      |L2.4|
;;;289    }
00000c  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.TM7705_Read2Byte||, CODE, READONLY, ALIGN=2

                  TM7705_Read2Byte PROC
;;;444    */
;;;445    static uint16_t TM7705_Read2Byte(void)
000000  b510              PUSH     {r4,lr}
;;;446    {
;;;447    	uint16_t read;
;;;448    
;;;449    	CS_0();
000002  2180              MOVS     r1,#0x80
000004  4809              LDR      r0,|L3.44|
000006  f7fffffe          BL       GPIO_ResetBits
;;;450    	read = TM7705_Recive8Bit();
00000a  f7fffffe          BL       TM7705_Recive8Bit
00000e  4604              MOV      r4,r0
;;;451    	read <<= 8;
000010  f64f70ff          MOV      r0,#0xffff
000014  ea002404          AND      r4,r0,r4,LSL #8
;;;452    	read += TM7705_Recive8Bit();
000018  f7fffffe          BL       TM7705_Recive8Bit
00001c  4420              ADD      r0,r0,r4
00001e  b284              UXTH     r4,r0
;;;453    	CS_1();
000020  2180              MOVS     r1,#0x80
000022  4802              LDR      r0,|L3.44|
000024  f7fffffe          BL       GPIO_SetBits
;;;454    
;;;455    	return read;
000028  4620              MOV      r0,r4
;;;456    }
00002a  bd10              POP      {r4,pc}
;;;457    
                          ENDP

                  |L3.44|
                          DCD      0x40021400

                          AREA ||i.TM7705_Read3Byte||, CODE, READONLY, ALIGN=2

                  TM7705_Read3Byte PROC
;;;465    */
;;;466    static uint32_t TM7705_Read3Byte(void)
000000  b510              PUSH     {r4,lr}
;;;467    {
;;;468    	uint32_t read;
;;;469    
;;;470    	CS_0();
000002  2180              MOVS     r1,#0x80
000004  4809              LDR      r0,|L4.44|
000006  f7fffffe          BL       GPIO_ResetBits
;;;471    	read = TM7705_Recive8Bit();
00000a  f7fffffe          BL       TM7705_Recive8Bit
00000e  4604              MOV      r4,r0
;;;472    	read <<= 8;
000010  0224              LSLS     r4,r4,#8
;;;473    	read += TM7705_Recive8Bit();
000012  f7fffffe          BL       TM7705_Recive8Bit
000016  4404              ADD      r4,r4,r0
;;;474    	read <<= 8;
000018  0224              LSLS     r4,r4,#8
;;;475    	read += TM7705_Recive8Bit();
00001a  f7fffffe          BL       TM7705_Recive8Bit
00001e  4404              ADD      r4,r4,r0
;;;476    	CS_1();
000020  2180              MOVS     r1,#0x80
000022  4802              LDR      r0,|L4.44|
000024  f7fffffe          BL       GPIO_SetBits
;;;477    	return read;
000028  4620              MOV      r0,r4
;;;478    }
00002a  bd10              POP      {r4,pc}
;;;479    
                          ENDP

                  |L4.44|
                          DCD      0x40021400

                          AREA ||i.TM7705_ReadAdc||, CODE, READONLY, ALIGN=1

                  TM7705_ReadAdc PROC
;;;695    */
;;;696    uint16_t TM7705_ReadAdc(uint8_t _ch)
000000  b570              PUSH     {r4-r6,lr}
;;;697    {
000002  4604              MOV      r4,r0
;;;698    	uint8_t i;
;;;699    	uint16_t read = 0;
000004  2600              MOVS     r6,#0
;;;700    
;;;701    	/* 为了避免通道切换造成读数失效，读2次 */
;;;702    	for (i = 0; i < 2; i++)
000006  2500              MOVS     r5,#0
000008  e011              B        |L5.46|
                  |L5.10|
;;;703    	{
;;;704    		TM7705_WaitDRDY();		/* 等待DRDY口线为0 */
00000a  f7fffffe          BL       TM7705_WaitDRDY
;;;705    
;;;706    		if (_ch == 1)
00000e  2c01              CMP      r4,#1
000010  d103              BNE      |L5.26|
;;;707    		{
;;;708    			TM7705_WriteByte(0x38);
000012  2038              MOVS     r0,#0x38
000014  f7fffffe          BL       TM7705_WriteByte
000018  e004              B        |L5.36|
                  |L5.26|
;;;709    		}
;;;710    		else if (_ch == 2)
00001a  2c02              CMP      r4,#2
00001c  d102              BNE      |L5.36|
;;;711    		{
;;;712    			TM7705_WriteByte(0x39);
00001e  2039              MOVS     r0,#0x39
000020  f7fffffe          BL       TM7705_WriteByte
                  |L5.36|
;;;713    		}
;;;714    
;;;715    		read = TM7705_Read2Byte();
000024  f7fffffe          BL       TM7705_Read2Byte
000028  4606              MOV      r6,r0
00002a  1c68              ADDS     r0,r5,#1              ;702
00002c  b2c5              UXTB     r5,r0                 ;702
                  |L5.46|
00002e  2d02              CMP      r5,#2                 ;702
000030  dbeb              BLT      |L5.10|
;;;716    	}
;;;717    	return read;
000032  4630              MOV      r0,r6
;;;718    }
000034  bd70              POP      {r4-r6,pc}
;;;719    
                          ENDP


                          AREA ||i.TM7705_ReadByte||, CODE, READONLY, ALIGN=2

                  TM7705_ReadByte PROC
;;;425    */
;;;426    static uint8_t TM7705_ReadByte(void)
000000  b510              PUSH     {r4,lr}
;;;427    {
;;;428    	uint8_t read;
;;;429    
;;;430    	CS_0();
000002  2180              MOVS     r1,#0x80
000004  4805              LDR      r0,|L6.28|
000006  f7fffffe          BL       GPIO_ResetBits
;;;431    	read = TM7705_Recive8Bit();
00000a  f7fffffe          BL       TM7705_Recive8Bit
00000e  4604              MOV      r4,r0
;;;432    	CS_1();
000010  2180              MOVS     r1,#0x80
000012  4802              LDR      r0,|L6.28|
000014  f7fffffe          BL       GPIO_SetBits
;;;433    
;;;434    	return read;
000018  4620              MOV      r0,r4
;;;435    }
00001a  bd10              POP      {r4,pc}
;;;436    
                          ENDP

                  |L6.28|
                          DCD      0x40021400

                          AREA ||i.TM7705_ReadReg||, CODE, READONLY, ALIGN=1

                  TM7705_ReadReg PROC
;;;564    */
;;;565    uint32_t TM7705_ReadReg(uint8_t _RegID)
000000  b570              PUSH     {r4-r6,lr}
;;;566    {
000002  4605              MOV      r5,r0
;;;567    	uint8_t bits;
;;;568    	uint32_t read;
;;;569    
;;;570    	switch (_RegID)
000004  2d60              CMP      r5,#0x60
000006  d013              BEQ      |L7.48|
000008  dc07              BGT      |L7.26|
00000a  b16d              CBZ      r5,|L7.40|
00000c  2d10              CMP      r5,#0x10
00000e  d00c              BEQ      |L7.42|
000010  2d20              CMP      r5,#0x20
000012  d00b              BEQ      |L7.44|
000014  2d30              CMP      r5,#0x30
000016  d110              BNE      |L7.58|
000018  e010              B        |L7.60|
                  |L7.26|
00001a  2d61              CMP      r5,#0x61
00001c  d00a              BEQ      |L7.52|
00001e  2d70              CMP      r5,#0x70
000020  d007              BEQ      |L7.50|
000022  2d71              CMP      r5,#0x71
000024  d109              BNE      |L7.58|
000026  e006              B        |L7.54|
                  |L7.40|
;;;571    	{
;;;572    		case REG_COMM:		/* 通信寄存器 */
;;;573    		case REG_SETUP:		/* 设置寄存器 8bit */
000028  bf00              NOP      
                  |L7.42|
;;;574    		case REG_CLOCK:		/* 时钟寄存器 8bit */
00002a  bf00              NOP      
                  |L7.44|
;;;575    			bits = 8;
00002c  2408              MOVS     r4,#8
;;;576    			break;
00002e  e008              B        |L7.66|
                  |L7.48|
;;;577    
;;;578    		case REG_ZERO_CH1:	/* CH1 偏移寄存器 24bit */
;;;579    		case REG_FULL_CH1:	/* CH1 满量程寄存器 24bit */
000030  bf00              NOP      
                  |L7.50|
;;;580    		case REG_ZERO_CH2:	/* CH2 偏移寄存器 24bit */
000032  bf00              NOP      
                  |L7.52|
;;;581    		case REG_FULL_CH2:	/* CH2 满量程寄存器 24bit*/
000034  bf00              NOP      
                  |L7.54|
;;;582    			bits = 24;
000036  2418              MOVS     r4,#0x18
;;;583    			break;
000038  e003              B        |L7.66|
                  |L7.58|
;;;584    
;;;585    		case REG_DATA:		/* 数据寄存器 16bit */
00003a  bf00              NOP      
                  |L7.60|
;;;586    		default:
;;;587    			return 0xFFFFFFFF;
00003c  f04f30ff          MOV      r0,#0xffffffff
                  |L7.64|
;;;588    	}
;;;589    
;;;590    	TM7705_WriteByte(_RegID | READ);	/* 写通信寄存器, 指定下一步是写操作，并指定写哪个寄存器 */
;;;591    
;;;592    	if (bits == 16)
;;;593    	{
;;;594    		read = TM7705_Read2Byte();
;;;595    	}
;;;596    	else if (bits == 8)
;;;597    	{
;;;598    		read = TM7705_ReadByte();
;;;599    	}
;;;600    	else	/* 24bit */
;;;601    	{
;;;602    		read = TM7705_Read3Byte();
;;;603    	}
;;;604    	return read;
;;;605    }
000040  bd70              POP      {r4-r6,pc}
                  |L7.66|
000042  bf00              NOP                            ;576
000044  f0450008          ORR      r0,r5,#8              ;590
000048  f7fffffe          BL       TM7705_WriteByte
00004c  2c10              CMP      r4,#0x10              ;592
00004e  d103              BNE      |L7.88|
000050  f7fffffe          BL       TM7705_Read2Byte
000054  4606              MOV      r6,r0                 ;594
000056  e008              B        |L7.106|
                  |L7.88|
000058  2c08              CMP      r4,#8                 ;596
00005a  d103              BNE      |L7.100|
00005c  f7fffffe          BL       TM7705_ReadByte
000060  4606              MOV      r6,r0                 ;598
000062  e002              B        |L7.106|
                  |L7.100|
000064  f7fffffe          BL       TM7705_Read3Byte
000068  4606              MOV      r6,r0                 ;602
                  |L7.106|
00006a  4630              MOV      r0,r6                 ;604
00006c  e7e8              B        |L7.64|
;;;606    
                          ENDP


                          AREA ||i.TM7705_Recive8Bit||, CODE, READONLY, ALIGN=2

                  TM7705_Recive8Bit PROC
;;;365    */
;;;366    static uint8_t TM7705_Recive8Bit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
;;;368    	uint8_t i;
;;;369    	uint8_t read = 0;
000002  2400              MOVS     r4,#0
;;;370    
;;;371    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e017              B        |L8.56|
                  |L8.8|
;;;372    	{
;;;373    		SCK_0();
000008  2108              MOVS     r1,#8
00000a  480d              LDR      r0,|L8.64|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;374    		TM7705_Delay();
000010  f7fffffe          BL       TM7705_Delay
;;;375    		read = read<<1;
000014  0660              LSLS     r0,r4,#25
000016  0e04              LSRS     r4,r0,#24
;;;376    		if (DO_IS_HIGH())
000018  2110              MOVS     r1,#0x10
00001a  4809              LDR      r0,|L8.64|
00001c  f7fffffe          BL       GPIO_ReadInputDataBit
000020  2801              CMP      r0,#1
000022  d101              BNE      |L8.40|
;;;377    		{
;;;378    			read++;
000024  1c60              ADDS     r0,r4,#1
000026  b2c4              UXTB     r4,r0
                  |L8.40|
;;;379    		}
;;;380    		SCK_1();
000028  2108              MOVS     r1,#8
00002a  4805              LDR      r0,|L8.64|
00002c  f7fffffe          BL       GPIO_SetBits
;;;381    		TM7705_Delay();
000030  f7fffffe          BL       TM7705_Delay
000034  1c68              ADDS     r0,r5,#1              ;371
000036  b2c5              UXTB     r5,r0                 ;371
                  |L8.56|
000038  2d08              CMP      r5,#8                 ;371
00003a  dbe5              BLT      |L8.8|
;;;382    	}
;;;383    	return read;
00003c  4620              MOV      r0,r4
;;;384    }
00003e  bd70              POP      {r4-r6,pc}
;;;385    
                          ENDP

                  |L8.64|
                          DCD      0x40020400

                          AREA ||i.TM7705_ResetHard||, CODE, READONLY, ALIGN=2

                  TM7705_ResetHard PROC
;;;298    */
;;;299    static void TM7705_ResetHard(void)
000000  b510              PUSH     {r4,lr}
;;;300    {
;;;301    	RESET_1();
000002  2110              MOVS     r1,#0x10
000004  480a              LDR      r0,|L9.48|
000006  f7fffffe          BL       GPIO_SetBits
;;;302    	bsp_DelayMS(1);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       bsp_DelayMS
;;;303    	RESET_0();
000010  2110              MOVS     r1,#0x10
000012  4807              LDR      r0,|L9.48|
000014  f7fffffe          BL       GPIO_ResetBits
;;;304    	bsp_DelayMS(2);
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       bsp_DelayMS
;;;305    	RESET_1();
00001e  2110              MOVS     r1,#0x10
000020  4803              LDR      r0,|L9.48|
000022  f7fffffe          BL       GPIO_SetBits
;;;306    	bsp_DelayMS(1);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       bsp_DelayMS
;;;307    }
00002c  bd10              POP      {r4,pc}
;;;308    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      0x40020000

                          AREA ||i.TM7705_Send8Bit||, CODE, READONLY, ALIGN=2

                  TM7705_Send8Bit PROC
;;;335    */
;;;336    static void TM7705_Send8Bit(uint8_t _data)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
000002  4604              MOV      r4,r0
;;;338    	uint8_t i;
;;;339    
;;;340    	for(i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e01b              B        |L10.64|
                  |L10.8|
;;;341    	{
;;;342    		if (_data & 0x80)
000008  f0140f80          TST      r4,#0x80
00000c  d004              BEQ      |L10.24|
;;;343    		{
;;;344    			DI_1();
00000e  2120              MOVS     r1,#0x20
000010  480d              LDR      r0,|L10.72|
000012  f7fffffe          BL       GPIO_SetBits
000016  e003              B        |L10.32|
                  |L10.24|
;;;345    		}
;;;346    		else
;;;347    		{
;;;348    			DI_0();
000018  2120              MOVS     r1,#0x20
00001a  480b              LDR      r0,|L10.72|
00001c  f7fffffe          BL       GPIO_ResetBits
                  |L10.32|
;;;349    		}
;;;350    		SCK_0();
000020  2108              MOVS     r1,#8
000022  4809              LDR      r0,|L10.72|
000024  f7fffffe          BL       GPIO_ResetBits
;;;351    		_data <<= 1;
000028  0660              LSLS     r0,r4,#25
00002a  0e04              LSRS     r4,r0,#24
;;;352    		TM7705_Delay();
00002c  f7fffffe          BL       TM7705_Delay
;;;353    		SCK_1();
000030  2108              MOVS     r1,#8
000032  4805              LDR      r0,|L10.72|
000034  f7fffffe          BL       GPIO_SetBits
;;;354    		TM7705_Delay();
000038  f7fffffe          BL       TM7705_Delay
00003c  1c68              ADDS     r0,r5,#1              ;340
00003e  b2c5              UXTB     r5,r0                 ;340
                  |L10.64|
000040  2d08              CMP      r5,#8                 ;340
000042  dbe1              BLT      |L10.8|
;;;355    	}
;;;356    }
000044  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      0x40020400

                          AREA ||i.TM7705_SyncSPI||, CODE, READONLY, ALIGN=2

                  TM7705_SyncSPI PROC
;;;316    */
;;;317    static void TM7705_SyncSPI(void)
000000  b510              PUSH     {r4,lr}
;;;318    {
;;;319    	/* AD7705串行接口失步后将其复位。复位后要延时500us再访问 */
;;;320    	CS_0();
000002  2180              MOVS     r1,#0x80
000004  4809              LDR      r0,|L11.44|
000006  f7fffffe          BL       GPIO_ResetBits
;;;321    	TM7705_Send8Bit(0xFF);
00000a  20ff              MOVS     r0,#0xff
00000c  f7fffffe          BL       TM7705_Send8Bit
;;;322    	TM7705_Send8Bit(0xFF);
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       TM7705_Send8Bit
;;;323    	TM7705_Send8Bit(0xFF);
000016  20ff              MOVS     r0,#0xff
000018  f7fffffe          BL       TM7705_Send8Bit
;;;324    	TM7705_Send8Bit(0xFF);
00001c  20ff              MOVS     r0,#0xff
00001e  f7fffffe          BL       TM7705_Send8Bit
;;;325    	CS_1();
000022  2180              MOVS     r1,#0x80
000024  4801              LDR      r0,|L11.44|
000026  f7fffffe          BL       GPIO_SetBits
;;;326    }
00002a  bd10              POP      {r4,pc}
;;;327    
                          ENDP

                  |L11.44|
                          DCD      0x40021400

                          AREA ||i.TM7705_SytemCalibFull||, CODE, READONLY, ALIGN=1

                  TM7705_SytemCalibFull PROC
;;;669    */
;;;670    void TM7705_SytemCalibFull(uint8_t _ch)
000000  b510              PUSH     {r4,lr}
;;;671    {
000002  4604              MOV      r4,r0
;;;672    	if (_ch == 1)
000004  2c01              CMP      r4,#1
000006  d108              BNE      |L12.26|
;;;673    	{
;;;674    		/* 校准CH1 */
;;;675    		TM7705_WriteByte(REG_SETUP | WRITE | CH_1);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       TM7705_WriteByte
;;;676    		TM7705_WriteByte(MD_CAL_FULL | __CH1_GAIN_BIPOLAR_BUF | FSYNC_0);/* 启动自校准 */
00000e  20c6              MOVS     r0,#0xc6
000010  f7fffffe          BL       TM7705_WriteByte
;;;677    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
000014  f7fffffe          BL       TM7705_WaitDRDY
000018  e009              B        |L12.46|
                  |L12.26|
;;;678    	}
;;;679    	else if (_ch == 2)
00001a  2c02              CMP      r4,#2
00001c  d107              BNE      |L12.46|
;;;680    	{
;;;681    		/* 校准CH2 */
;;;682    		TM7705_WriteByte(REG_SETUP | WRITE | CH_2);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
00001e  2011              MOVS     r0,#0x11
000020  f7fffffe          BL       TM7705_WriteByte
;;;683    		TM7705_WriteByte(MD_CAL_FULL | __CH2_GAIN_BIPOLAR_BUF | FSYNC_0);	/* 启动自校准 */
000024  20c6              MOVS     r0,#0xc6
000026  f7fffffe          BL       TM7705_WriteByte
;;;684    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
00002a  f7fffffe          BL       TM7705_WaitDRDY
                  |L12.46|
;;;685    	}
;;;686    }
00002e  bd10              POP      {r4,pc}
;;;687    
                          ENDP


                          AREA ||i.TM7705_SytemCalibZero||, CODE, READONLY, ALIGN=1

                  TM7705_SytemCalibZero PROC
;;;642    */
;;;643    void TM7705_SytemCalibZero(uint8_t _ch)
000000  b510              PUSH     {r4,lr}
;;;644    {
000002  4604              MOV      r4,r0
;;;645    	if (_ch == 1)
000004  2c01              CMP      r4,#1
000006  d108              BNE      |L13.26|
;;;646    	{
;;;647    		/* 校准CH1 */
;;;648    		TM7705_WriteByte(REG_SETUP | WRITE | CH_1);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       TM7705_WriteByte
;;;649    		TM7705_WriteByte(MD_CAL_ZERO | __CH1_GAIN_BIPOLAR_BUF | FSYNC_0);/* 启动自校准 */
00000e  2086              MOVS     r0,#0x86
000010  f7fffffe          BL       TM7705_WriteByte
;;;650    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
000014  f7fffffe          BL       TM7705_WaitDRDY
000018  e009              B        |L13.46|
                  |L13.26|
;;;651    	}
;;;652    	else if (_ch == 2)
00001a  2c02              CMP      r4,#2
00001c  d107              BNE      |L13.46|
;;;653    	{
;;;654    		/* 校准CH2 */
;;;655    		TM7705_WriteByte(REG_SETUP | WRITE | CH_2);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
00001e  2011              MOVS     r0,#0x11
000020  f7fffffe          BL       TM7705_WriteByte
;;;656    		TM7705_WriteByte(MD_CAL_ZERO | __CH2_GAIN_BIPOLAR_BUF | FSYNC_0);	/* 启动自校准 */
000024  2086              MOVS     r0,#0x86
000026  f7fffffe          BL       TM7705_WriteByte
;;;657    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
00002a  f7fffffe          BL       TM7705_WaitDRDY
                  |L13.46|
;;;658    	}
;;;659    }
00002e  bd10              POP      {r4,pc}
;;;660    
                          ENDP


                          AREA ||i.TM7705_WaitDRDY||, CODE, READONLY, ALIGN=2

                  TM7705_WaitDRDY PROC
;;;487    */
;;;488    static void TM7705_WaitDRDY(void)
000000  b510              PUSH     {r4,lr}
;;;489    {
;;;490    	uint32_t i;
;;;491    
;;;492    	/* 如果初始化时未检测到芯片则快速返回，避免影响主程序响应速度 */
;;;493    	if (g_TM7705_OK == 0)
000002  480c              LDR      r0,|L14.52|
000004  7800              LDRB     r0,[r0,#0]  ; g_TM7705_OK
000006  b900              CBNZ     r0,|L14.10|
                  |L14.8|
;;;494    	{
;;;495    		return;
;;;496    	}
;;;497    	
;;;498    	for (i = 0; i < 4000000; i++)
;;;499    	{
;;;500    		if (DRDY_IS_LOW())
;;;501    		{
;;;502    			break;
;;;503    		}
;;;504    	}
;;;505    	if (i >= 4000000)
;;;506    	{
;;;507    		printf("TM7705_WaitDRDY() Time Out ...\r\n");		/* 调试语句. 用语排错 */
;;;508    	}
;;;509    }
000008  bd10              POP      {r4,pc}
                  |L14.10|
00000a  2400              MOVS     r4,#0                 ;498
00000c  e006              B        |L14.28|
                  |L14.14|
00000e  2180              MOVS     r1,#0x80              ;500
000010  4809              LDR      r0,|L14.56|
000012  f7fffffe          BL       GPIO_ReadInputDataBit
000016  b900              CBNZ     r0,|L14.26|
000018  e003              B        |L14.34|
                  |L14.26|
00001a  1c64              ADDS     r4,r4,#1              ;498
                  |L14.28|
00001c  4807              LDR      r0,|L14.60|
00001e  4284              CMP      r4,r0                 ;498
000020  d3f5              BCC      |L14.14|
                  |L14.34|
000022  bf00              NOP                            ;502
000024  4805              LDR      r0,|L14.60|
000026  4284              CMP      r4,r0                 ;505
000028  d302              BCC      |L14.48|
00002a  a005              ADR      r0,|L14.64|
00002c  f7fffffe          BL       __2printf
                  |L14.48|
000030  bf00              NOP      
000032  e7e9              B        |L14.8|
;;;510    
                          ENDP

                  |L14.52|
                          DCD      g_TM7705_OK
                  |L14.56|
                          DCD      0x40021c00
                  |L14.60|
                          DCD      0x003d0900
                  |L14.64|
000040  544d3737          DCB      "TM7705_WaitDRDY() Time Out ...\r\n",0
000044  30355f57
000048  61697444
00004c  52445928
000050  29205469
000054  6d65204f
000058  7574202e
00005c  2e2e0d0a
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.TM7705_Write3Byte||, CODE, READONLY, ALIGN=2

                  TM7705_Write3Byte PROC
;;;408    */
;;;409    static void TM7705_Write3Byte(uint32_t _data)
000000  b510              PUSH     {r4,lr}
;;;410    {
000002  4604              MOV      r4,r0
;;;411    	CS_0();
000004  2180              MOVS     r1,#0x80
000006  4809              LDR      r0,|L15.44|
000008  f7fffffe          BL       GPIO_ResetBits
;;;412    	TM7705_Send8Bit((_data >> 16) & 0xFF);
00000c  f3c44007          UBFX     r0,r4,#16,#8
000010  f7fffffe          BL       TM7705_Send8Bit
;;;413    	TM7705_Send8Bit((_data >> 8) & 0xFF);
000014  f3c42007          UBFX     r0,r4,#8,#8
000018  f7fffffe          BL       TM7705_Send8Bit
;;;414    	TM7705_Send8Bit(_data);
00001c  b2e0              UXTB     r0,r4
00001e  f7fffffe          BL       TM7705_Send8Bit
;;;415    	CS_1();
000022  2180              MOVS     r1,#0x80
000024  4801              LDR      r0,|L15.44|
000026  f7fffffe          BL       GPIO_SetBits
;;;416    }
00002a  bd10              POP      {r4,pc}
;;;417    
                          ENDP

                  |L15.44|
                          DCD      0x40021400

                          AREA ||i.TM7705_WriteByte||, CODE, READONLY, ALIGN=2

                  TM7705_WriteByte PROC
;;;393    */
;;;394    static void TM7705_WriteByte(uint8_t _data)
000000  b510              PUSH     {r4,lr}
;;;395    {
000002  4604              MOV      r4,r0
;;;396    	CS_0();
000004  2180              MOVS     r1,#0x80
000006  4805              LDR      r0,|L16.28|
000008  f7fffffe          BL       GPIO_ResetBits
;;;397    	TM7705_Send8Bit(_data);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TM7705_Send8Bit
;;;398    	CS_1();
000012  2180              MOVS     r1,#0x80
000014  4801              LDR      r0,|L16.28|
000016  f7fffffe          BL       GPIO_SetBits
;;;399    }
00001a  bd10              POP      {r4,pc}
;;;400    
                          ENDP

                  |L16.28|
                          DCD      0x40021400

                          AREA ||i.TM7705_WriteReg||, CODE, READONLY, ALIGN=1

                  TM7705_WriteReg PROC
;;;519    */
;;;520    void TM7705_WriteReg(uint8_t _RegID, uint32_t _RegValue)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;522    	uint8_t bits;
;;;523    
;;;524    	switch (_RegID)
000006  2c60              CMP      r4,#0x60
000008  d013              BEQ      |L17.50|
00000a  dc07              BGT      |L17.28|
00000c  b16c              CBZ      r4,|L17.42|
00000e  2c10              CMP      r4,#0x10
000010  d00c              BEQ      |L17.44|
000012  2c20              CMP      r4,#0x20
000014  d00b              BEQ      |L17.46|
000016  2c30              CMP      r4,#0x30
000018  d110              BNE      |L17.60|
00001a  e010              B        |L17.62|
                  |L17.28|
00001c  2c61              CMP      r4,#0x61
00001e  d00a              BEQ      |L17.54|
000020  2c70              CMP      r4,#0x70
000022  d007              BEQ      |L17.52|
000024  2c71              CMP      r4,#0x71
000026  d109              BNE      |L17.60|
000028  e006              B        |L17.56|
                  |L17.42|
;;;525    	{
;;;526    		case REG_COMM:		/* 通信寄存器 */
;;;527    		case REG_SETUP:		/* 设置寄存器 8bit */
00002a  bf00              NOP      
                  |L17.44|
;;;528    		case REG_CLOCK:		/* 时钟寄存器 8bit */
00002c  bf00              NOP      
                  |L17.46|
;;;529    			bits = 8;
00002e  2608              MOVS     r6,#8
;;;530    			break;
000030  e006              B        |L17.64|
                  |L17.50|
;;;531    
;;;532    		case REG_ZERO_CH1:	/* CH1 偏移寄存器 24bit */
;;;533    		case REG_FULL_CH1:	/* CH1 满量程寄存器 24bit */
000032  bf00              NOP      
                  |L17.52|
;;;534    		case REG_ZERO_CH2:	/* CH2 偏移寄存器 24bit */
000034  bf00              NOP      
                  |L17.54|
;;;535    		case REG_FULL_CH2:	/* CH2 满量程寄存器 24bit*/
000036  bf00              NOP      
                  |L17.56|
;;;536    			bits = 24;
000038  2618              MOVS     r6,#0x18
;;;537    			break;
00003a  e001              B        |L17.64|
                  |L17.60|
;;;538    
;;;539    		case REG_DATA:		/* 数据寄存器 16bit */
00003c  bf00              NOP      
                  |L17.62|
;;;540    		default:
;;;541    			return;
;;;542    	}
;;;543    
;;;544    	TM7705_WriteByte(_RegID | WRITE);	/* 写通信寄存器, 指定下一步是写操作，并指定写哪个寄存器 */
;;;545    
;;;546    	if (bits == 8)
;;;547    	{
;;;548    		TM7705_WriteByte((uint8_t)_RegValue);
;;;549    	}
;;;550    	else	/* 24bit */
;;;551    	{
;;;552    		TM7705_Write3Byte(_RegValue);
;;;553    	}
;;;554    }
00003e  bd70              POP      {r4-r6,pc}
                  |L17.64|
000040  bf00              NOP                            ;530
000042  4620              MOV      r0,r4                 ;544
000044  f7fffffe          BL       TM7705_WriteByte
000048  2e08              CMP      r6,#8                 ;546
00004a  d103              BNE      |L17.84|
00004c  b2e8              UXTB     r0,r5                 ;548
00004e  f7fffffe          BL       TM7705_WriteByte
000052  e002              B        |L17.90|
                  |L17.84|
000054  4628              MOV      r0,r5                 ;552
000056  f7fffffe          BL       TM7705_Write3Byte
                  |L17.90|
00005a  bf00              NOP      
00005c  e7ef              B        |L17.62|
;;;555    
                          ENDP


                          AREA ||i.bsp_InitTM7705||, CODE, READONLY, ALIGN=2

                  bsp_InitTM7705 PROC
;;;194    */
;;;195    void bsp_InitTM7705(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;196    {
;;;197    	GPIO_InitTypeDef GPIO_InitStructure;
;;;198    
;;;199    #ifdef SOFT_SPI		/* 软件SPI */
;;;200    	CS_1();
000002  2180              MOVS     r1,#0x80
000004  4836              LDR      r0,|L18.224|
000006  f7fffffe          BL       GPIO_SetBits
;;;201    	SCK_1();
00000a  2108              MOVS     r1,#8
00000c  4835              LDR      r0,|L18.228|
00000e  f7fffffe          BL       GPIO_SetBits
;;;202    	DI_1();
000012  2120              MOVS     r1,#0x20
000014  4833              LDR      r0,|L18.228|
000016  f7fffffe          BL       GPIO_SetBits
;;;203    
;;;204    	/* 打开GPIO时钟 */
;;;205    	RCC_AHB1PeriphClockCmd(RCC_SCK | RCC_DIN | RCC_DOUT | RCC_CS | RCC_DRDY | RCC_RESET, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  20a3              MOVS     r0,#0xa3
00001e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;206    
;;;207    	/* 配置几个推完输出IO */
;;;208    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
000022  2001              MOVS     r0,#1
000024  f88d0004          STRB     r0,[sp,#4]
;;;209    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000028  2000              MOVS     r0,#0
00002a  f88d0006          STRB     r0,[sp,#6]
;;;210    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
00002e  f88d0007          STRB     r0,[sp,#7]
;;;211    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
000032  2003              MOVS     r0,#3
000034  f88d0005          STRB     r0,[sp,#5]
;;;212    
;;;213    	GPIO_InitStructure.GPIO_Pin = PIN_SCK;
000038  2008              MOVS     r0,#8
00003a  9000              STR      r0,[sp,#0]
;;;214    	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4829              LDR      r0,|L18.228|
000040  f7fffffe          BL       GPIO_Init
;;;215    
;;;216    	GPIO_InitStructure.GPIO_Pin = PIN_DIN;
000044  2020              MOVS     r0,#0x20
000046  9000              STR      r0,[sp,#0]
;;;217    	GPIO_Init(PORT_DIN, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  4826              LDR      r0,|L18.228|
00004c  f7fffffe          BL       GPIO_Init
;;;218    
;;;219    	GPIO_InitStructure.GPIO_Pin = PIN_CS;
000050  2080              MOVS     r0,#0x80
000052  9000              STR      r0,[sp,#0]
;;;220    	GPIO_Init(PORT_CS, &GPIO_InitStructure);
000054  4669              MOV      r1,sp
000056  4822              LDR      r0,|L18.224|
000058  f7fffffe          BL       GPIO_Init
;;;221    
;;;222    	GPIO_InitStructure.GPIO_Pin = PIN_RESET;
00005c  2010              MOVS     r0,#0x10
00005e  9000              STR      r0,[sp,#0]
;;;223    	GPIO_Init(PORT_RESET, &GPIO_InitStructure);
000060  4669              MOV      r1,sp
000062  4821              LDR      r0,|L18.232|
000064  f7fffffe          BL       GPIO_Init
;;;224    
;;;225    	/* 配置GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;226    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* 设为输入口 */
000068  2000              MOVS     r0,#0
00006a  f88d0004          STRB     r0,[sp,#4]
;;;227    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
00006e  f88d0006          STRB     r0,[sp,#6]
;;;228    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 无需上下拉电阻 */
000072  f88d0007          STRB     r0,[sp,#7]
;;;229    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
000076  2002              MOVS     r0,#2
000078  f88d0005          STRB     r0,[sp,#5]
;;;230    
;;;231    	GPIO_InitStructure.GPIO_Pin = PIN_DOUT;
00007c  2010              MOVS     r0,#0x10
00007e  9000              STR      r0,[sp,#0]
;;;232    	GPIO_Init(PORT_DOUT, &GPIO_InitStructure);
000080  4669              MOV      r1,sp
000082  4818              LDR      r0,|L18.228|
000084  f7fffffe          BL       GPIO_Init
;;;233    
;;;234    	GPIO_InitStructure.GPIO_Pin = PIN_DRDY;
000088  2080              MOVS     r0,#0x80
00008a  9000              STR      r0,[sp,#0]
;;;235    	GPIO_Init(PORT_DRDY, &GPIO_InitStructure);
00008c  4669              MOV      r1,sp
00008e  4817              LDR      r0,|L18.236|
000090  f7fffffe          BL       GPIO_Init
;;;236    
;;;237    #endif
;;;238    
;;;239    	bsp_DelayMS(10);
000094  200a              MOVS     r0,#0xa
000096  f7fffffe          BL       bsp_DelayMS
;;;240    
;;;241    	TM7705_ResetHard();		/* 硬件复位 */
00009a  f7fffffe          BL       TM7705_ResetHard
;;;242    
;;;243    	/*
;;;244    		在接口序列丢失的情况下，如果在DIN 高电平的写操作持续了足够长的时间（至少 32个串行时钟周期），
;;;245    		TM7705 将会回到默认状态。
;;;246    	*/
;;;247    	bsp_DelayMS(5);
00009e  2005              MOVS     r0,#5
0000a0  f7fffffe          BL       bsp_DelayMS
;;;248    
;;;249    	TM7705_SyncSPI();		/* 同步SPI接口时序 */
0000a4  f7fffffe          BL       TM7705_SyncSPI
;;;250    
;;;251    	bsp_DelayMS(5);
0000a8  2005              MOVS     r0,#5
0000aa  f7fffffe          BL       bsp_DelayMS
;;;252    	
;;;253    	/* 复位之后, 时钟寄存器应该是 0x05 */
;;;254    	{						
;;;255    		if (TM7705_ReadReg(REG_CLOCK) == 0x05)
0000ae  2020              MOVS     r0,#0x20
0000b0  f7fffffe          BL       TM7705_ReadReg
0000b4  2805              CMP      r0,#5
0000b6  d103              BNE      |L18.192|
;;;256    		{
;;;257    			g_TM7705_OK = 1;
0000b8  2001              MOVS     r0,#1
0000ba  490d              LDR      r1,|L18.240|
0000bc  7008              STRB     r0,[r1,#0]
0000be  e002              B        |L18.198|
                  |L18.192|
;;;258    		}
;;;259    		else
;;;260    		{
;;;261    			g_TM7705_OK = 0;
0000c0  2000              MOVS     r0,#0
0000c2  490b              LDR      r1,|L18.240|
0000c4  7008              STRB     r0,[r1,#0]
                  |L18.198|
;;;262    		}
;;;263    	}	
;;;264    
;;;265    	/* 配置时钟寄存器 */
;;;266    	TM7705_WriteByte(REG_CLOCK | WRITE | CH_1);			/* 先写通信寄存器，下一步是写时钟寄存器 */
0000c6  2020              MOVS     r0,#0x20
0000c8  f7fffffe          BL       TM7705_WriteByte
;;;267    
;;;268    	TM7705_WriteByte(CLKDIS_0 | CLK_4_9152M | FS_50HZ);	/* 刷新速率50Hz */
0000cc  2008              MOVS     r0,#8
0000ce  f7fffffe          BL       TM7705_WriteByte
;;;269    	//TM7705_WriteByte(CLKDIS_0 | CLK_4_9152M | FS_500HZ);	/* 刷新速率500Hz */
;;;270    
;;;271    	/* 每次上电进行一次自校准 */
;;;272    	TM7705_CalibSelf(1);	/* 内部自校准 CH1 */
0000d2  2001              MOVS     r0,#1
0000d4  f7fffffe          BL       TM7705_CalibSelf
;;;273    	bsp_DelayMS(5);
0000d8  2005              MOVS     r0,#5
0000da  f7fffffe          BL       bsp_DelayMS
;;;274    }
0000de  bd1c              POP      {r2-r4,pc}
;;;275    
                          ENDP

                  |L18.224|
                          DCD      0x40021400
                  |L18.228|
                          DCD      0x40020400
                  |L18.232|
                          DCD      0x40020000
                  |L18.236|
                          DCD      0x40021c00
                  |L18.240|
                          DCD      g_TM7705_OK

                          AREA ||.data||, DATA, ALIGN=0

                  g_TM7705_OK
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_tm7705.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_tm7705_c_24319657____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_tm7705_c_24319657____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_bsp_tm7705_c_24319657____REVSH|
#line 144
|__asm___12_bsp_tm7705_c_24319657____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
